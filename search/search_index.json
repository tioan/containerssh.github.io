{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ContainerSSH: Launch containers on demand Offering SSH in a web hosting service? ContainerSSH lets you dynamically create and destroy containers when your users connect. Authenticate against your existing user database and mount directories based on your existing permission matrix. Read more \u00bb Looking for a Linux learning environment? With ContainerSSH you can launch Linux-based containers on demand when your students connect. You can supply your own container image and mount folders with learning and testing material as needed. Read more \u00bb Building a honeypot? With the dynamic authentication server of ContainerSSH you can capture usernames and passwords, and you container environment can log commands that are executed. Read more \u00bb Building a high security environment? ContainerSSH is being used to provide dynamic console access to an environment with sensitive credentials. Use the authentication and configuration server to dynamically provision credentials in conjunction with secret management systems such as Hashicorp Vault. Read more \u00bb How does it work? \u00b6 +------+ +--------------+ 2. +-------------------+ | | | | -----> | Auth server | | | | | +-------------------+ | | | | | | 1. | | 3. +-------------------+ | User | -----> | ContainerSSH | -----> | Config server | | | | | +-------------------+ | | | | | | | | 4. +-------------------+ | | | | -----> | Container Backend | +------+ +--------------+ +-------------------+ The user opens an SSH connection to ContainerSSH. ContainerSSH calls the authentication server with the users username and password/pubkey to check if it is valid. ContainerSSH calls the config server to obtain backend location and configuration (if configured). ContainerSSH calls the container backend to launch the container with the specified configuration. All input from the user is sent directly to the backend, output from the container is sent to the user. Get started \u00bb","title":"Home"},{"location":"#how-does-it-work","text":"+------+ +--------------+ 2. +-------------------+ | | | | -----> | Auth server | | | | | +-------------------+ | | | | | | 1. | | 3. +-------------------+ | User | -----> | ContainerSSH | -----> | Config server | | | | | +-------------------+ | | | | | | | | 4. +-------------------+ | | | | -----> | Container Backend | +------+ +--------------+ +-------------------+ The user opens an SSH connection to ContainerSSH. ContainerSSH calls the authentication server with the users username and password/pubkey to check if it is valid. ContainerSSH calls the config server to obtain backend location and configuration (if configured). ContainerSSH calls the container backend to launch the container with the specified configuration. All input from the user is sent directly to the backend, output from the container is sent to the user. Get started \u00bb","title":"How does it work?"},{"location":"about/","text":"About ContainerSSH Who makes ContainerSSH? Why? \u00b6 ContainerSSH is a fully open source community-driven project . It is made with \u2764\ufe0f by the following group of volunteers. Janos Pasztor core maintainer Sanja Bonic core maintainer Richard Kovacs Note: this list is opt-in for privacy reasons. If you wish to be listed on this page please add your name here . Companies \u00b6 We use services and tools from the following companies for free: Docker Docker has accepted ContainerSSH into their Docker Open Source Program . The open source program exempts ContainerSSH from the Docker Hub rate limits , which is important to us because we are using it to host the default guest image . GitHub GitHub provides the core development infrastructure for ContainerSSH , as well as the continuous integration system and the hosting for this website. Terraform Cloud We use the Terraform Cloud by HashiCorp to automate the configuration of our GitHub organization.","title":"About ContainerSSH"},{"location":"about/#who-makes-containerssh-why","text":"ContainerSSH is a fully open source community-driven project . It is made with \u2764\ufe0f by the following group of volunteers. Janos Pasztor core maintainer Sanja Bonic core maintainer Richard Kovacs Note: this list is opt-in for privacy reasons. If you wish to be listed on this page please add your name here .","title":"Who makes ContainerSSH? Why?"},{"location":"about/#companies","text":"We use services and tools from the following companies for free:","title":"Companies"},{"location":"about/imprint/","text":"Imprint ContainerSSH is being developed by a community of volunteers . The project is maintained by Janos Pasztor and Sanja Bonic. For a postal address suitable for legal service please contact %68%61%6E%64%73%68%61%6B%65%40%63%6F%6E%74%61%69%6E%65%72%73%73%68%2E%69%6F . The address will be handed out to registered law firms and government agencies only.","title":"Imprint"},{"location":"about/license/","text":"License This website and the ContainerSSH source code is distributed under the MIT license with the following exceptions: To keep things fair the ContainerSSH name and logos may only be used in accordance with the ContainerSSH brand license . Company marks such as GitHub, Docker, Twitter, etc. Trademarks are properties of their respective owners and may only be used according to their trademark guidelines. Some decorative images licensed from Unsplash . MkDocs is distributed under the BSD license. Material for MkDocs is distributed under the MIT license. ContainerSSH binaries contain open source components under the following licenses: MIT BSD Apache 2.0 Mozilla ISC Details of these licenses can be found in the NOTICE.md file published with each release. The MIT License (MIT) \u00b6 Copyright (c) 2020 ContainerSSH contributors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#the-mit-license-mit","text":"Copyright (c) 2020 ContainerSSH contributors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"about/packages/","text":"ContainerSSH maintains a package repository at packages.containerssh.io . This page describes how to add the repository to your operating system. Debian/Ubuntu First, you need to add the tools needed for adding a custom repository: sudo apt-get update sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common Next, you should add our GnuPG key as a trusted key for packages: curl -fsSL https://packages.containerssh.io/debian/gpg | sudo apt-key add - Verify that you now have the correct fingerprint: sudo apt-key fingerprint F358FABA Add our repository: sudo add-apt-repository \\ \"deb [arch=amd64] https://packages.containerssh.io/debian ./\" Finally, refresh the package list: sudo apt-get update Now you can install the ContainerSSH packages.","title":"ContainerSSH packages"},{"location":"about/privacy/","text":"Privacy policy \u00b6 This is the privacy policy for the website projects.pasztor.at/containerssh. Cookies \u00b6 This website uses no cookies. Personal data collected by this website \u00b6 This website does not directly collect personal data. Third party providers \u00b6 This website is hosted on GitHub pages. As such, when loading this website, your IP address will be available and may be stored by GitHub in their accesslogs, along with the information which page specifically you loaded.","title":"Privacy Policy"},{"location":"about/privacy/#privacy-policy","text":"This is the privacy policy for the website projects.pasztor.at/containerssh.","title":"Privacy policy"},{"location":"about/privacy/#cookies","text":"This website uses no cookies.","title":"Cookies"},{"location":"about/privacy/#personal-data-collected-by-this-website","text":"This website does not directly collect personal data.","title":"Personal data collected by this website"},{"location":"about/privacy/#third-party-providers","text":"This website is hosted on GitHub pages. As such, when loading this website, your IP address will be available and may be stored by GitHub in their accesslogs, along with the information which page specifically you loaded.","title":"Third party providers"},{"location":"about/security/","text":"Security ContainerSSH is a security-relevant piece of software. If you have found any security issues you wish to report to us please mail %68%61%6E%64%73%68%61%6B%65%40%63%6F%6E%74%61%69%6E%65%72%73%73%68%2E%69%6F . We are also in the process of signing all our binaries, which is expected to complete during 2021. Our GPG key \u00b6 You may use the following GPG key to encrypt messages to us. This key is always available at https://containerssh.io/gpg.txt . -----BEGIN PGP PUBLIC KEY BLOCK----- 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 1IxE =/NjK -----END PGP PUBLIC KEY BLOCK-----","title":"Security"},{"location":"about/security/#our-gpg-key","text":"You may use the following GPG key to encrypt messages to us. This key is always available at https://containerssh.io/gpg.txt . -----BEGIN PGP PUBLIC KEY BLOCK----- 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 1IxE =/NjK -----END PGP PUBLIC KEY BLOCK-----","title":"Our GPG key"},{"location":"advanced/audit/","text":"Audit logging ( upcoming in 0.4.0 ) Warning This is a feature still in development and is available in 0.4.0 Preview Release 1 ContainerSSH contains an audit logging facility that can log every interaction happening over SSH. This functionality is disabled by default as it has serious security and privacy implications, as well as severe resource requirements. Audit logging can be enabled in the configuration using the following structure: audit : format : none|audit|asciinema # Which format to log in. Defaults to none. storage : none|s3|file # Where to write audit log. Defaults to none. intercept : stdin : true|false # Intercept keystrokes from user stdout : true|false # Intercept standard output stderr : true|false # Intercept standard error passwords : true|false # Intercept passwords during authentication Audit logging is a powerful tool. It can capture the following events. Connections Authentication attempts, optionally with credentials Global and channel-specific SSH requests Programs launched from SSH Input from the user (optional) Output and errors to the user (optional) The events recorded depend on the chosen format. With the audit format all information is recorded with nanosecond timing, so events can be accurately reconstructed after the fact. About interceptions \u00b6 The intercept options give you a wide range of options when it comes to detailed logging of actions by users. You may want to, for example, enable stdout logging while keeping stdin disabled to avoid accidentally capturing passwords typed into the console. However, this approach may fail if SFTP is enabled as you will fail to capture binaries uploaded to the server. Audit logging should therefore be enjoyed with great care and the logs should always be stored on an encrypted storage device. Log formats \u00b6 The audit format (recommended) \u00b6 The audit format is intended for an accurate reconstruction of everything happening during an SSH session. It allows for accurate reconstruction of what happened during the session. Audit logs are stored in a compressed binary format and can be decoded to a series of JSON messages using the containerssh-auditlog-decoder supplied as part of the ContainerSSH release. Alternatively, you can implement your own decoder . The asciinema format \u00b6 The asciinema format stores logs in a format suitable for replay in the Asciinema player . Note Make sure you enable the stdout and stderr interceptions otherwise the asciinema encoder won't capture anything. Warning Asciinema is intended for entertainment purposes only and doesn't store all relevant information required for an accurate audit log. Storage backends \u00b6 The s3 storage (recommended) \u00b6 The S3 storage sends the logs to an S3-compatible object storage for long term storage. This is the recommended way of storing audit logs because it is a server-independent storage device that supports permissions. The S3 storage stores the logs in a local directory and uploads them once an upload part is full (default: 5MB) or the connection closes. If the upload fails, ContainerSSH will retry the upload as soon as possible. If ContainerSSH is stopped and restarted it will attempt to upload the audit logs still in the local directory, but no guarantee is made that these logs will not be corrupt after a crash. Warning The local directory should be stored on a persistent storage and must not be shared between ContainerSSH instances. It must be large enough to host all sessions in their entirety that are currently running. When IO interception is enabled and your users are downloading or uploading large amounts of data this can run you up to several GB of storage needed locally. We recommend turning off IO interception for cases where large amounts of data are being transferred. The S3 storage can be configured as follows: audit : storage : s3 s3 : local : /local/storage/directory accessKey : \"your-access-key-here\" secretKey : \"your-secret-key-here\" bucket : \"your-existing-bucket-name-here\" region : \"your-region-name-here\" endpoint : \"https://your-custom-s3-url\" # Optional uploadPartSize : 5242880 # In bytes, min: 5MB, max: 5GB acl : \"public-read\" # Optional, in case you want to set an ACL metadata : username : true # Expose username via S3 metadata. Defaults to false. ip : true # Expose IP address via S3 metadata. Defaults to false. cacert : | # Optional Your trusted CA certificate in PEM format here for your S3 server. Tip You can restrict the access key permissions to PutObject , CreateMultipartUpload , UploadPart , CompleteMultipartUpload , ListMultipartUploads , and AbortMultipartUpload . Other permissions are not required. Tip You may also want to investigate if your S3 provider supports WORM / object locking, object lifecycles, or server side encryption for compliance. The file storage \u00b6 The file storage writes audit logs to files on the disk. The storage location can be configured using the following option: audit : type : file file : directory : /var/log/audit","title":"Audit logging"},{"location":"advanced/audit/#about-interceptions","text":"The intercept options give you a wide range of options when it comes to detailed logging of actions by users. You may want to, for example, enable stdout logging while keeping stdin disabled to avoid accidentally capturing passwords typed into the console. However, this approach may fail if SFTP is enabled as you will fail to capture binaries uploaded to the server. Audit logging should therefore be enjoyed with great care and the logs should always be stored on an encrypted storage device.","title":"About interceptions"},{"location":"advanced/audit/#log-formats","text":"","title":"Log formats"},{"location":"advanced/audit/#the-audit-format-recommended","text":"The audit format is intended for an accurate reconstruction of everything happening during an SSH session. It allows for accurate reconstruction of what happened during the session. Audit logs are stored in a compressed binary format and can be decoded to a series of JSON messages using the containerssh-auditlog-decoder supplied as part of the ContainerSSH release. Alternatively, you can implement your own decoder .","title":"The audit format (recommended)"},{"location":"advanced/audit/#the-asciinema-format","text":"The asciinema format stores logs in a format suitable for replay in the Asciinema player . Note Make sure you enable the stdout and stderr interceptions otherwise the asciinema encoder won't capture anything. Warning Asciinema is intended for entertainment purposes only and doesn't store all relevant information required for an accurate audit log.","title":"The asciinema format"},{"location":"advanced/audit/#storage-backends","text":"","title":"Storage backends"},{"location":"advanced/audit/#the-s3-storage-recommended","text":"The S3 storage sends the logs to an S3-compatible object storage for long term storage. This is the recommended way of storing audit logs because it is a server-independent storage device that supports permissions. The S3 storage stores the logs in a local directory and uploads them once an upload part is full (default: 5MB) or the connection closes. If the upload fails, ContainerSSH will retry the upload as soon as possible. If ContainerSSH is stopped and restarted it will attempt to upload the audit logs still in the local directory, but no guarantee is made that these logs will not be corrupt after a crash. Warning The local directory should be stored on a persistent storage and must not be shared between ContainerSSH instances. It must be large enough to host all sessions in their entirety that are currently running. When IO interception is enabled and your users are downloading or uploading large amounts of data this can run you up to several GB of storage needed locally. We recommend turning off IO interception for cases where large amounts of data are being transferred. The S3 storage can be configured as follows: audit : storage : s3 s3 : local : /local/storage/directory accessKey : \"your-access-key-here\" secretKey : \"your-secret-key-here\" bucket : \"your-existing-bucket-name-here\" region : \"your-region-name-here\" endpoint : \"https://your-custom-s3-url\" # Optional uploadPartSize : 5242880 # In bytes, min: 5MB, max: 5GB acl : \"public-read\" # Optional, in case you want to set an ACL metadata : username : true # Expose username via S3 metadata. Defaults to false. ip : true # Expose IP address via S3 metadata. Defaults to false. cacert : | # Optional Your trusted CA certificate in PEM format here for your S3 server. Tip You can restrict the access key permissions to PutObject , CreateMultipartUpload , UploadPart , CompleteMultipartUpload , ListMultipartUploads , and AbortMultipartUpload . Other permissions are not required. Tip You may also want to investigate if your S3 provider supports WORM / object locking, object lifecycles, or server side encryption for compliance.","title":"The s3 storage (recommended)"},{"location":"advanced/audit/#the-file-storage","text":"The file storage writes audit logs to files on the disk. The storage location can be configured using the following option: audit : type : file file : directory : /var/log/audit","title":"The file storage"},{"location":"advanced/hardening/","text":"Hardening ContainerSSH ContainerSSH is built to secure its inner workings as much as possible. You can take several steps to secure it further. Running ContainerSSH \u00b6 The default ContainerSSH image runs as a non-root user by default and exposes itself on port 2222. If you decide to build your own installation make sure ContainerSSH does not run as root as it is not required. Secure your Docker/Kubernetes \u00b6 Depending on which backend you are using you have to take different steps to secure it. When using Docker ContainerSSH will need access to the Docker socket. This undeniably means that ContainerSSH will be able to launch root processes on the host machine. You may want to look into running Docker in rootless mode or switching to Podman When running Kubernetes it is strongly advised that you deploy a pod security policy and a network policy. You should also make sure that ContainerSSH uses a restricted service account that can only access its own namespace. Securing your auth server \u00b6 Your authentication server contains all your secrets and is therefore a prime target. ContainerSSH delegates any and all access checking to the authentication server. Therefore, you need to make sure it prevents brute force attacks. Furthermore, you should make sure that the authentication server cannot be accessed from anywhere else. You can do this using firewalls. Alternatively, you can configure ContainerSSH to use client certificates to authenticate itself: auth : url : http://127.0.0.1:8080 cacert : \"insert your expected CA certificate in PEM format here\" timeout : 2s cert : \"insert your client certificate in PEM format here\" key : \"insert your client key in PEM format here\" Securing your config server \u00b6 Similar to your authentication server you can also secure the config server in a similar manner: configserver : timeout : 2s url : http://127.0.0.1:8080/config cacert : \"insert your expected CA certificate in PEM format here\" cert : \"insert your client certificate in PEM format here\" key : \"insert your client key in PEM format here\" Disabling command execution ( since 0.2.1 ) \u00b6 You can disable the execution of custom SSH commands through the configuration: dockerrun : config : disableCommand : true kuberun : pod : disableCommand : true Note Disabling command execution also disables SFTP integration.","title":"Hardening"},{"location":"advanced/hardening/#running-containerssh","text":"The default ContainerSSH image runs as a non-root user by default and exposes itself on port 2222. If you decide to build your own installation make sure ContainerSSH does not run as root as it is not required.","title":"Running ContainerSSH"},{"location":"advanced/hardening/#secure-your-dockerkubernetes","text":"Depending on which backend you are using you have to take different steps to secure it. When using Docker ContainerSSH will need access to the Docker socket. This undeniably means that ContainerSSH will be able to launch root processes on the host machine. You may want to look into running Docker in rootless mode or switching to Podman When running Kubernetes it is strongly advised that you deploy a pod security policy and a network policy. You should also make sure that ContainerSSH uses a restricted service account that can only access its own namespace.","title":"Secure your Docker/Kubernetes"},{"location":"advanced/hardening/#securing-your-auth-server","text":"Your authentication server contains all your secrets and is therefore a prime target. ContainerSSH delegates any and all access checking to the authentication server. Therefore, you need to make sure it prevents brute force attacks. Furthermore, you should make sure that the authentication server cannot be accessed from anywhere else. You can do this using firewalls. Alternatively, you can configure ContainerSSH to use client certificates to authenticate itself: auth : url : http://127.0.0.1:8080 cacert : \"insert your expected CA certificate in PEM format here\" timeout : 2s cert : \"insert your client certificate in PEM format here\" key : \"insert your client key in PEM format here\"","title":"Securing your auth server"},{"location":"advanced/hardening/#securing-your-config-server","text":"Similar to your authentication server you can also secure the config server in a similar manner: configserver : timeout : 2s url : http://127.0.0.1:8080/config cacert : \"insert your expected CA certificate in PEM format here\" cert : \"insert your client certificate in PEM format here\" key : \"insert your client key in PEM format here\"","title":"Securing your config server"},{"location":"advanced/hardening/#disabling-command-execution-since-021","text":"You can disable the execution of custom SSH commands through the configuration: dockerrun : config : disableCommand : true kuberun : pod : disableCommand : true Note Disabling command execution also disables SFTP integration.","title":"Disabling command execution (since 0.2.1)"},{"location":"advanced/image/","text":"Building a container image for ContainerSSH ContainerSSH can run any Linux container image. However, it is strongly recommended that you install the ContainerSSH guest agent into the image to make all features available. If you wish to use SFTP you have to add an SFTP server ( apt install openssh-sftp-server on Ubuntu) to the container image and configure the path of the SFTP server correctly in your config.yaml. The sample image containerssh/containerssh-guest-image contains an SFTP server.","title":"Creating an Image"},{"location":"advanced/logging/","text":"Logging ( since 0.2.2 ) ContainerSSH comes with configurable logging facilities. At this time only JSON logging is supported, but the log level can be configured. The configuration can be done from the config file: log: level: \"warning\" Tip You can configure the log level on a per-user basis using the configuration server . The supported levels are in accordance with the Syslog standard: debug info notice warning error crit alert emerg The JSON log format \u00b6 The JSON log format outputs one line to the output per message. The message format is: { \"timestamp\" : \"Timestamp in RFC3339 format\" , \"level\" : \"the log level\" , \"message\" : \"the message (optional)\" , \"details\" : { \"the detail object if any (optional)\" } } Note The JSON logger writes to the standard output regardless of log level. Note In case of a fatal application crash (panic), the crash log will end up on the stderr. Make sure to capture that as well for emergency debugging.","title":"Logging"},{"location":"advanced/logging/#the-json-log-format","text":"The JSON log format outputs one line to the output per message. The message format is: { \"timestamp\" : \"Timestamp in RFC3339 format\" , \"level\" : \"the log level\" , \"message\" : \"the message (optional)\" , \"details\" : { \"the detail object if any (optional)\" } } Note The JSON logger writes to the standard output regardless of log level. Note In case of a fatal application crash (panic), the crash log will end up on the stderr. Make sure to capture that as well for emergency debugging.","title":"The JSON log format"},{"location":"advanced/metrics/","text":"Metrics ( since 0.3.0 ) ContainerSSH contains a Prometheus -compatible metrics server which can be enabled using the following configuration: metrics : enable : true # Defaults to false listen : \"0.0.0.0:9100\" # Set the listen address here path : \"/metrics\" # Defaults to /metrics You can configure Prometheus to grab the following metrics: containerssh_auth_server_failures Number of failed requests to the authentication server since start. containerssh_auth_success Number of successful authentications since start. Contains labels for authtype ( password or pubkey ) and country (see below). containerssh_auth_failures Number of failed authentications since start. Contains labels for authtype ( password or pubkey ) and country (see below). containerssh_config_server_failures Number of failed requests to the configuration server since start. containerssh_ssh_connections Number of SSH connections since start. Contains a label for country (see below). containerssh_ssh_handshake_successful Number of successful SSH handshakes since start. Contains a label for country (see below). containerssh_ssh_handshake_failed Number of failed SSH handshakes since start. Contains a label for country (see below). containerssh_ssh_current_connections Number of currently open SSH connections. Contains a label for country (see below). Country identification \u00b6 Country identification works using GeoIP2 or GeoLite2 from MaxMind . This database needs to be provided to ContainerSSH externally due to licensing concerns. The default path for the GeoIP database is /var/lib/GeoIP/GeoIP2-Country.mmdb , but you can change that using the following configuration snippet: geoip : maxmind-geoip2-file : '/var/lib/GeoIP/GeoIP2-Country.mmdb'","title":"Metrics"},{"location":"advanced/metrics/#country-identification","text":"Country identification works using GeoIP2 or GeoLite2 from MaxMind . This database needs to be provided to ContainerSSH externally due to licensing concerns. The default path for the GeoIP database is /var/lib/GeoIP/GeoIP2-Country.mmdb , but you can change that using the following configuration snippet: geoip : maxmind-geoip2-file : '/var/lib/GeoIP/GeoIP2-Country.mmdb'","title":"Country identification"},{"location":"api/","text":"ContainerSSH itself does not have an API apart from exposing the metrics . However, it requires two external APIs: the authentication server for user authentication and the config server for supplying a user-specific container configuration. We are providing an OpenAPI document for both. Access the OpenAPI docs \u00bb","title":"About the API"},{"location":"blog/2020/11/25/the-road-to-0-4/","text":"The road to ContainerSSH 0.4: modularized structure, audit logging, and more \u00b6 November 25, 2020 After a rapid rush of releases this summer we have announced that version 0.4.0 would have a long-awaited feature: detailed audit logging . This feature would allow for a forensic reconstruction of an SSH session. The use cases for this are diverse: from building honeypots to securing a corporate environment. We even published a preview release for test driving this feature. We even implemented an automatic upload for the audit logs to an S3-compatible object storage. So, what happened? Why isn't 0.4.0 released yet? The delay has everything to do with maintainability . The PR-1 implementation of the audit logging was built right into ContainerSSH causing a deluge of code changes. While it technically worked, it blew up the code in size and made features extremely hard to test. Look at this code, for example . The actual authentication code dwarfs in comparison to the audit logging parts. You could say, the code violates the Single Responsibility Principle . There is no way we could retrofit component-level tests into this. When we began work on ContainerSSH we knew that the code quality was prototype-level at best and we'd have to overhaul large parts before the 1.0 release. In essence, version 0.4 became the release to make that overhaul happen. We started pulling out large parts of the codebase into independent libraries and started retrofitting them with unittests. Needless to say, moving from only having a few integration tests to writing unittests for each component unearthed a slew of bugs, which were promptly fixed. Starting ContainerSSH with a prototyping approach wasn't a bad decision, though: it helped us getting something working fairly quickly and kept motivation high. This is especially important with a purely open source project. Pulling everything apart into separate libraries also gave us a couple of additional advantages. We created developer documentation for each library , and we now also have the ability to extend ContainerSSH in a significant way. ContainerSSH now has clean APIs to handle SSH events . These clean APIs allow developers to plug in additional functionality without breaking any existing features. For example, the audit log functionality is integrated in a separate repository with this approach . Using a layered approach gives us quite a few options. One idea we are toying with is to create an SSH proxy that forwards connections to a backend SSH server. This would allow users to deploy ContainerSSH as a pure audit logging facility. Another idea is to build in PAM authentication and enable a direct shell on the host , which would enable ContainerSSH to function as a replacement for OpenSSH with the added functionality of audit logging. If you like these ideas please comment on the issues linked above and let us know about your use case . So, when is 0.4 coming out? We don't know yet. Our plan is early next year , but our focus in this release is stability.","title":" The road to ContainerSSH 0.4: modularized structure, audit logging, and more"},{"location":"blog/2020/11/25/the-road-to-0-4/#the-road-to-containerssh-04-modularized-structure-audit-logging-and-more","text":"November 25, 2020 After a rapid rush of releases this summer we have announced that version 0.4.0 would have a long-awaited feature: detailed audit logging . This feature would allow for a forensic reconstruction of an SSH session. The use cases for this are diverse: from building honeypots to securing a corporate environment. We even published a preview release for test driving this feature. We even implemented an automatic upload for the audit logs to an S3-compatible object storage. So, what happened? Why isn't 0.4.0 released yet? The delay has everything to do with maintainability . The PR-1 implementation of the audit logging was built right into ContainerSSH causing a deluge of code changes. While it technically worked, it blew up the code in size and made features extremely hard to test. Look at this code, for example . The actual authentication code dwarfs in comparison to the audit logging parts. You could say, the code violates the Single Responsibility Principle . There is no way we could retrofit component-level tests into this. When we began work on ContainerSSH we knew that the code quality was prototype-level at best and we'd have to overhaul large parts before the 1.0 release. In essence, version 0.4 became the release to make that overhaul happen. We started pulling out large parts of the codebase into independent libraries and started retrofitting them with unittests. Needless to say, moving from only having a few integration tests to writing unittests for each component unearthed a slew of bugs, which were promptly fixed. Starting ContainerSSH with a prototyping approach wasn't a bad decision, though: it helped us getting something working fairly quickly and kept motivation high. This is especially important with a purely open source project. Pulling everything apart into separate libraries also gave us a couple of additional advantages. We created developer documentation for each library , and we now also have the ability to extend ContainerSSH in a significant way. ContainerSSH now has clean APIs to handle SSH events . These clean APIs allow developers to plug in additional functionality without breaking any existing features. For example, the audit log functionality is integrated in a separate repository with this approach . Using a layered approach gives us quite a few options. One idea we are toying with is to create an SSH proxy that forwards connections to a backend SSH server. This would allow users to deploy ContainerSSH as a pure audit logging facility. Another idea is to build in PAM authentication and enable a direct shell on the host , which would enable ContainerSSH to function as a replacement for OpenSSH with the added functionality of audit logging. If you like these ideas please comment on the issues linked above and let us know about your use case . So, when is 0.4 coming out? We don't know yet. Our plan is early next year , but our focus in this release is stability.","title":"The road to ContainerSSH 0.4: modularized structure, audit logging, and more"},{"location":"blog/2020/12/24/the-agent/","text":"ContainerSSH is an integration project between the SSH library and the Docker and Kubernetes API. However, neither the Docker nor the Kubernetes API have been designed to host some of the more intricate SSH specific features. For example, the Kubernetes \"attach\" API does not allow for retrieving the output of the command running in the container that happened before attaching reliably,and neither Docker nor Kubernetes allow sending signals to commands running in an \"exec\", etc. We won't go into details on these various issues, suffice it to say, some of them break the expectations you would have for a classic SSH server. There are two paths ahead of us: either try to send pull requests to the Docker and Kubernetes projects to patch these features in, or add a guest agent to the container images that enable these extra features. Sending in patches to enable all the functionality would be a very long process and chances are that our patches wouldn't be accepted as they add additional functionality that is, admittedly, fringe for most users. Therefore, we opted to build a guest agent . The ContainerSSH guest agent is a binary containing only minimal functionality and no external dependencies that can easily be added to any container image as a single binary. We have already added it to the default containerssh/containerssh-guest-image and we encourage users who built their own image to include the agent as well and keep it updated. Please see github.com/containerssh/agent for details. That being said, the guest image is and will be optional. It will be a feature that needs to be explicitly enabled in the configuration. Guest agent support will arrive in ContainerSSH 0.4 after the holidays. Merry Christmas and Happy Holidays!","title":" Announcing the ContainerSSH Guest Agent"},{"location":"deprecations/","text":"Deprecated and removed ContainerSSH features \u00b6 This page lists all features that have been removed or deprecated. You can click each one to learn more about how to transition from the deprecated or removed feature. Feature Deprecated Removed listen option 0.4 \u2014 dockerrun backend 0.4 \u2014 kuberun backend 0.4 \u2014","title":"Deprecations"},{"location":"deprecations/#deprecated-and-removed-containerssh-features","text":"This page lists all features that have been removed or deprecated. You can click each one to learn more about how to transition from the deprecated or removed feature. Feature Deprecated Removed listen option 0.4 \u2014 dockerrun backend 0.4 \u2014 kuberun backend 0.4 \u2014","title":"Deprecated and removed ContainerSSH features"},{"location":"deprecations/dockerrun/","text":"Deprecating the DockerRun backend ( upcoming in 0.4 ) \u00b6 In version 0.4 ContainerSSH receives a generalized docker backend and we are deprecating the dockerrun backend from version 0.3.1 and earlier. We are adding this new backend because we are changing several default values to options which could cause security problems if the old configuration was used. Version 0.4 still includes support for the dockerrun backend, but log a warning when used: You are using the dockerrun backend deprecated since ContainerSSH 0.4. This backend will be removed in the future. Please switch to the new docker backend as soon as possible. See https://containerssh.io/deprecations/dockerrun for details. This page explains how to switch to the new backend. Changing the configuration structure \u00b6 The new configuration is structured into 3 components: docker : connection : # These options were on the root level of the dockerrun configuration. host : cacert : cert : key : execution : # These options are moved here from the old dockerrun -> config option. container : # ... host : # ... network : # ... platform : # ... containername : \"\" # Subsystems that can be requested. subsystems : sftp : /usr/lib/openssh/sftp-server # the \"disableCommand\" option has been removed and is configured in the # \"security\" option. # Pick an image pull policy from \"Always\", \"IfNotPresent\" or \"Never\". See below. imagePullPolicy : \"IfNotPresent\" # Execution mode, see below. mode : connection # Idle command for the new \"connection\" mode, see below. idleCommand : - \"/bin/sh\" - \"-c\" - \"sleep infinity & PID=$!; trap \\\"kill $PID\\\" INT TERM; wait\" # Shell command for the new \"connection\" mode, see below. shellCommand : - \"/bin/bash\" # Path to the new ContainerSSH Guest Agent. agentPath : \"/usr/bin/containerssh-agent\" # Disable the ContainerSSH guest agent. disableAgent : true timeouts : # This section replaces the dockerrun -> config -> timeout option. # Timeout for a container to start. containerStart : 60s # Timeout for a container to stop. containerStop : 60s # Timeout for a shell or command to start. commandStart : 60s # Timeout for HTTP calls http : 15s # Timeout for signal requests signal : 60s # Timeout for window change requests window : 60s The new execution modes \u00b6 The new docker backend supports two execution modes: connection or session . The old dockerrun backend worked identical to the session mode, where each command execution within an SSH connection would cause a new container to be started. The new connection mode, on the other hand, starts a container with an idle command from the configuration and then uses the docker exec facility to launch commands. In connection mode the pods are launched with the command specified in docker \u2192 execution \u2192 idleCommand as a command. The purpose of this command is to keep the pod alive and wait for a TERM signal. Any commands (shell, etc.) will be launched similar to how you would use docker exec to run an additional command in the pod. When a shell is requested the docker \u2192 execution \u2192 shellCommand parameter is used. Warning The connection execution mode means that the CMD and ENTRYPOINT settings from the container image or the configuration are ignored. If you are switching from the dockerrun backend and used the CMD as a security measure it is strongly recommended that you configure the idleCommand and shellCommand options properly. The guest agent \u00b6 ContainerSSH 0.4 also includes support for the new ContainerSSH Guest Agent that enables support for various features the Docker API does not provide, such as sending signals to processes. The agent must be included into the guest image in order to work. When the agent is included it can be configured as follows: docker : execution : # Path to the new ContainerSSH Guest Agent. agentPath : \"/usr/bin/containerssh-agent\" # Disable the ContainerSSH guest agent. disableAgent : true Warning The agent is enabled by default, you should explicitly disable it if you want to run an image that doesn't have an integrated agent. Image pull policy \u00b6 The new docker backend also includes an option when to pull images. This option helps with the Docker Hub rate limits and is built to be similar to the Kubernetes option with the same name . Tip Docker has added ContainerSSH as an Open Source Community Application . Pulls to containerssh/containerssh and the default guest image containerssh/containerssh-guest-image are excluded from the rate limits. docker : execution : # Pick an image pull policy from \"Always\", \"IfNotPresent\" or \"Never\". See below. imagePullPolicy : \"IfNotPresent\" The following options are supported: Always Always pulls images. This is the same behavior as the dockerrun backend. IfNotPresent Pull image if it is not locally present, has no image tag, or has the :latest tag. Never Never pulls the image. If the image is not locally present the execution will fail. Removing the disableCommand option \u00b6 The disableCommand option was added to ContainerSSH to prevent connecting users to run a custom application. This filled a similar role to the ForceCommand option in OpenSSH: it prevented connecting users to launch custom commands. However, this command was separately implemented in the kuberun and in the dockerrun backend. This was not maintainable, so it was moved into the security module and can be configured as follows: security : command : mode : disable","title":"Deprecating the DockerRun backend"},{"location":"deprecations/dockerrun/#deprecating-the-dockerrun-backend-upcoming-in-04","text":"In version 0.4 ContainerSSH receives a generalized docker backend and we are deprecating the dockerrun backend from version 0.3.1 and earlier. We are adding this new backend because we are changing several default values to options which could cause security problems if the old configuration was used. Version 0.4 still includes support for the dockerrun backend, but log a warning when used: You are using the dockerrun backend deprecated since ContainerSSH 0.4. This backend will be removed in the future. Please switch to the new docker backend as soon as possible. See https://containerssh.io/deprecations/dockerrun for details. This page explains how to switch to the new backend.","title":"Deprecating the DockerRun backend (upcoming in 0.4)"},{"location":"deprecations/dockerrun/#changing-the-configuration-structure","text":"The new configuration is structured into 3 components: docker : connection : # These options were on the root level of the dockerrun configuration. host : cacert : cert : key : execution : # These options are moved here from the old dockerrun -> config option. container : # ... host : # ... network : # ... platform : # ... containername : \"\" # Subsystems that can be requested. subsystems : sftp : /usr/lib/openssh/sftp-server # the \"disableCommand\" option has been removed and is configured in the # \"security\" option. # Pick an image pull policy from \"Always\", \"IfNotPresent\" or \"Never\". See below. imagePullPolicy : \"IfNotPresent\" # Execution mode, see below. mode : connection # Idle command for the new \"connection\" mode, see below. idleCommand : - \"/bin/sh\" - \"-c\" - \"sleep infinity & PID=$!; trap \\\"kill $PID\\\" INT TERM; wait\" # Shell command for the new \"connection\" mode, see below. shellCommand : - \"/bin/bash\" # Path to the new ContainerSSH Guest Agent. agentPath : \"/usr/bin/containerssh-agent\" # Disable the ContainerSSH guest agent. disableAgent : true timeouts : # This section replaces the dockerrun -> config -> timeout option. # Timeout for a container to start. containerStart : 60s # Timeout for a container to stop. containerStop : 60s # Timeout for a shell or command to start. commandStart : 60s # Timeout for HTTP calls http : 15s # Timeout for signal requests signal : 60s # Timeout for window change requests window : 60s","title":"Changing the configuration structure"},{"location":"deprecations/dockerrun/#the-new-execution-modes","text":"The new docker backend supports two execution modes: connection or session . The old dockerrun backend worked identical to the session mode, where each command execution within an SSH connection would cause a new container to be started. The new connection mode, on the other hand, starts a container with an idle command from the configuration and then uses the docker exec facility to launch commands. In connection mode the pods are launched with the command specified in docker \u2192 execution \u2192 idleCommand as a command. The purpose of this command is to keep the pod alive and wait for a TERM signal. Any commands (shell, etc.) will be launched similar to how you would use docker exec to run an additional command in the pod. When a shell is requested the docker \u2192 execution \u2192 shellCommand parameter is used. Warning The connection execution mode means that the CMD and ENTRYPOINT settings from the container image or the configuration are ignored. If you are switching from the dockerrun backend and used the CMD as a security measure it is strongly recommended that you configure the idleCommand and shellCommand options properly.","title":"The new execution modes"},{"location":"deprecations/dockerrun/#the-guest-agent","text":"ContainerSSH 0.4 also includes support for the new ContainerSSH Guest Agent that enables support for various features the Docker API does not provide, such as sending signals to processes. The agent must be included into the guest image in order to work. When the agent is included it can be configured as follows: docker : execution : # Path to the new ContainerSSH Guest Agent. agentPath : \"/usr/bin/containerssh-agent\" # Disable the ContainerSSH guest agent. disableAgent : true Warning The agent is enabled by default, you should explicitly disable it if you want to run an image that doesn't have an integrated agent.","title":"The guest agent"},{"location":"deprecations/dockerrun/#image-pull-policy","text":"The new docker backend also includes an option when to pull images. This option helps with the Docker Hub rate limits and is built to be similar to the Kubernetes option with the same name . Tip Docker has added ContainerSSH as an Open Source Community Application . Pulls to containerssh/containerssh and the default guest image containerssh/containerssh-guest-image are excluded from the rate limits. docker : execution : # Pick an image pull policy from \"Always\", \"IfNotPresent\" or \"Never\". See below. imagePullPolicy : \"IfNotPresent\" The following options are supported: Always Always pulls images. This is the same behavior as the dockerrun backend. IfNotPresent Pull image if it is not locally present, has no image tag, or has the :latest tag. Never Never pulls the image. If the image is not locally present the execution will fail.","title":"Image pull policy"},{"location":"deprecations/dockerrun/#removing-the-disablecommand-option","text":"The disableCommand option was added to ContainerSSH to prevent connecting users to run a custom application. This filled a similar role to the ForceCommand option in OpenSSH: it prevented connecting users to launch custom commands. However, this command was separately implemented in the kuberun and in the dockerrun backend. This was not maintainable, so it was moved into the security module and can be configured as follows: security : command : mode : disable","title":"Removing the disableCommand option"},{"location":"deprecations/kuberun/","text":"Deprecating the KubeRun backend ( upcoming in 0.4 ) \u00b6 In version 0.4 ContainerSSH receives a generalized kubernetes backend and we are deprecating the kuberun backend from version 0.3.1 and earlier. We are adding this new backend because we are changing several default values to options which could cause security problems if the old configuration was used. Version 0.4 still includes support for the kuberun backend, but log a warning when used: You are using the kuberun backend deprecated since ContainerSSH 0.4. This backend will be removed in the future. Please switch to the new docker backend as soon as possible. See https://containerssh.io/deprecations/kuberun for details. This page explains how to switch to the new backend. Changing the configuration structure \u00b6 The new configuration structure is very similar to the old kuberun structure. The most important change is the relocated and more detailed timeouts section: kubernetes : timeouts : # Timeout for a container to start. podStart : 60s # Timeout for a container to stop. podStop : 60s # Timeout for a shell or command to start. commandStart : 60s # Timeout for HTTP calls http : 15s # Timeout for signal requests signal : 60s # Timeout for window change requests window : 60s This replaces the old kubernetes \u2192 connection \u2192 timeout option. The configuration now also moves the kubernetes \u2192 pod \u2192 namespace option to the new metadata section, which is can now be fully customized with Kubernetes pod metadata: kubernetes : pod : metadata : namespace : default generateName : myPodNamePrefix- labels : foo : bar Please run kubectl explain pod.metadata for the full list of options. The new execution modes \u00b6 The new kubernetes backend supports two execution modes: connection or session . The old kuberun backend worked identical to the session mode, where each command execution within an SSH connection would cause a new container to be started. The new connection mode, on the other hand, starts a container with an idle command from the configuration and then uses the exec facility to launch commands. In connection mode the pods are launched with the command specified in kubernetes \u2192 pod \u2192 idleCommand as a command. The purpose of this command is to keep the pod alive and wait for a TERM signal. Any commands (shell, etc.) will be launched similar to how you would use kubectl exec to run an additional command in the pod. When a shell is requested the kubernetes \u2192 pod \u2192 shellCommand parameter is used. Warning The connection execution mode means that the CMD and ENTRYPOINT settings from the container image or the configuration are ignored. If you are switching from the kuberun backend and used the CMD as a security measure it is strongly recommended that you configure the idleCommand and shellCommand options properly. The guest agent \u00b6 ContainerSSH 0.4 also includes support for the new ContainerSSH Guest Agent that enables several features the Kubernetes API does not support support. For example, the guest agent enables waiting for ContainerSSH to attach to the process in session mode before starting the desired program. It is strongly recommended to enable the guest agent for Kubernetes as the API misses several features required for proper operations. The agent must be included into the guest image in order to work. When the agent is included it can be configured as follows: kubernetes : pod : # Path to the new ContainerSSH Guest Agent. agentPath : \"/usr/bin/containerssh-agent\" # Disable the ContainerSSH guest agent. disableAgent : true Warning The agent is enabled by default, you should explicitly disable it if you want to run an image that doesn't have an integrated agent. Removing the disableCommand option \u00b6 The disableCommand option was added to ContainerSSH to prevent connecting users to run a custom application. This filled a similar role to the ForceCommand option in OpenSSH: it prevented connecting users to launch custom commands. However, this command was separately implemented in the kuberun and in the dockerrun backend. This was not maintainable, so it was moved into the security module and can be configured as follows: security : command : mode : disable","title":"Deprecating the KubeRun backend"},{"location":"deprecations/kuberun/#deprecating-the-kuberun-backend-upcoming-in-04","text":"In version 0.4 ContainerSSH receives a generalized kubernetes backend and we are deprecating the kuberun backend from version 0.3.1 and earlier. We are adding this new backend because we are changing several default values to options which could cause security problems if the old configuration was used. Version 0.4 still includes support for the kuberun backend, but log a warning when used: You are using the kuberun backend deprecated since ContainerSSH 0.4. This backend will be removed in the future. Please switch to the new docker backend as soon as possible. See https://containerssh.io/deprecations/kuberun for details. This page explains how to switch to the new backend.","title":"Deprecating the KubeRun backend (upcoming in 0.4)"},{"location":"deprecations/kuberun/#changing-the-configuration-structure","text":"The new configuration structure is very similar to the old kuberun structure. The most important change is the relocated and more detailed timeouts section: kubernetes : timeouts : # Timeout for a container to start. podStart : 60s # Timeout for a container to stop. podStop : 60s # Timeout for a shell or command to start. commandStart : 60s # Timeout for HTTP calls http : 15s # Timeout for signal requests signal : 60s # Timeout for window change requests window : 60s This replaces the old kubernetes \u2192 connection \u2192 timeout option. The configuration now also moves the kubernetes \u2192 pod \u2192 namespace option to the new metadata section, which is can now be fully customized with Kubernetes pod metadata: kubernetes : pod : metadata : namespace : default generateName : myPodNamePrefix- labels : foo : bar Please run kubectl explain pod.metadata for the full list of options.","title":"Changing the configuration structure"},{"location":"deprecations/kuberun/#the-new-execution-modes","text":"The new kubernetes backend supports two execution modes: connection or session . The old kuberun backend worked identical to the session mode, where each command execution within an SSH connection would cause a new container to be started. The new connection mode, on the other hand, starts a container with an idle command from the configuration and then uses the exec facility to launch commands. In connection mode the pods are launched with the command specified in kubernetes \u2192 pod \u2192 idleCommand as a command. The purpose of this command is to keep the pod alive and wait for a TERM signal. Any commands (shell, etc.) will be launched similar to how you would use kubectl exec to run an additional command in the pod. When a shell is requested the kubernetes \u2192 pod \u2192 shellCommand parameter is used. Warning The connection execution mode means that the CMD and ENTRYPOINT settings from the container image or the configuration are ignored. If you are switching from the kuberun backend and used the CMD as a security measure it is strongly recommended that you configure the idleCommand and shellCommand options properly.","title":"The new execution modes"},{"location":"deprecations/kuberun/#the-guest-agent","text":"ContainerSSH 0.4 also includes support for the new ContainerSSH Guest Agent that enables several features the Kubernetes API does not support support. For example, the guest agent enables waiting for ContainerSSH to attach to the process in session mode before starting the desired program. It is strongly recommended to enable the guest agent for Kubernetes as the API misses several features required for proper operations. The agent must be included into the guest image in order to work. When the agent is included it can be configured as follows: kubernetes : pod : # Path to the new ContainerSSH Guest Agent. agentPath : \"/usr/bin/containerssh-agent\" # Disable the ContainerSSH guest agent. disableAgent : true Warning The agent is enabled by default, you should explicitly disable it if you want to run an image that doesn't have an integrated agent.","title":"The guest agent"},{"location":"deprecations/kuberun/#removing-the-disablecommand-option","text":"The disableCommand option was added to ContainerSSH to prevent connecting users to run a custom application. This filled a similar role to the ForceCommand option in OpenSSH: it prevented connecting users to launch custom commands. However, this command was separately implemented in the kuberun and in the dockerrun backend. This was not maintainable, so it was moved into the security module and can be configured as follows: security : command : mode : disable","title":"Removing the disableCommand option"},{"location":"deprecations/listen/","text":"Moving the ContainerSSH listen option ( upcoming in 0.4 ) \u00b6 In ContainerSSH 0.4 we are introducing a framework to run multiple services within one daemon. In the future we want to add more services like a web-based interface. To make this change happen we will stop treating the SSH service as special , so we are moving the listen option from the configuration root to ssh \u2192 listen : # Deprecated version listen : 0.0.0.0:2222 # New version ssh : listen : 0.0.0.0:2222 If you use the old option you will receive the following log warning: You are using the 'listen' option deprecated in ContainerSSH 0.4. Please use the new 'ssh -> listen' option. See https://containerssh.io/deprecations/listen for details. If you provide both options the new option will take precedence and you will receive the following log message: You are using the 'listen' option deprecated in ContainerSSH 0.4 as well as the new 'ssh -> listen' option. The new option takes precedence. Please see https://containerssh.io/deprecations/listen for details.","title":"Moving the Listen option"},{"location":"deprecations/listen/#moving-the-containerssh-listen-option-upcoming-in-04","text":"In ContainerSSH 0.4 we are introducing a framework to run multiple services within one daemon. In the future we want to add more services like a web-based interface. To make this change happen we will stop treating the SSH service as special , so we are moving the listen option from the configuration root to ssh \u2192 listen : # Deprecated version listen : 0.0.0.0:2222 # New version ssh : listen : 0.0.0.0:2222 If you use the old option you will receive the following log warning: You are using the 'listen' option deprecated in ContainerSSH 0.4. Please use the new 'ssh -> listen' option. See https://containerssh.io/deprecations/listen for details. If you provide both options the new option will take precedence and you will receive the following log message: You are using the 'listen' option deprecated in ContainerSSH 0.4 as well as the new 'ssh -> listen' option. The new option takes precedence. Please see https://containerssh.io/deprecations/listen for details.","title":"Moving the ContainerSSH listen option (upcoming in 0.4)"},{"location":"development/","text":"Developing ContainerSSH Welcome! And a big thank you for wanting to contribute! This page will explain how to get started with contributing to ContainerSSH. This guide will help you through the basics of getting development up and running. Getting started This quick guide will help you hop into ContainerSSH development on the quick. Read more \u00bb Setting up your development environment This guide walks you though the steps needed to set up a development environment, from Git, through Goland and GPG, to the IDE. Read more \u00bb Dashboard Our development dashboard shows you the libraries, issues, and pull requests relevant to ContainerSSH development. Open Dashboard \u00bb Understanding ContainerSSH This document describes the concepts around SSH and how ContainerSSH is built internally. Read more \u00bb","title":"Overview"},{"location":"development/code-style/","text":"Coding style We don't have a strict coding convention that will force you to write code in a very specific way. Instead, we will try to explain how we think about ensuring quality in this document. Please, feel free to bring your own ideas and discuss on the discussions board . Object-Oriented Programming \u00b6 Wait, what? OOP in Go? Yes, bear with me. Go has a concept called receivers that allow you to pass a context structure to a function. This is very similar to how private and public variables are handled in OOP languages. The main benefit of receivers is that they can be used to implement interfaces . Interfaces, in turn, give us the ability to create a standardized API between components without involving a network. The log library , for example, provides the Logger interface and then also includes an implementation for the logger. However, at no point do we have a hard dependency on the actual implementation of the logger. If in the future the implementation turns out to be insufficient replacing it is easy. We use this pattern extensively to separate the ContainerSSH libraries from each other. We are then using these interfaces to write tests for each library without having to run an end-to-end test for every test. Testing \u00b6 This brings us to the topic of testing. ContainerSSH is a security-relevant software so we want to ensure a reasonable level of quality. In the beginning we had a manual testing protocol, but as features became more extensive it became very hard to test each feature for each release. We also rely on GitHub's Dependabot to update our external dependencies. Without tests we would have a very hard time verifying that the updated third party library did not break something. When it comes to test sizes we prefer having unit- or component-level tests and only have a few end-to-end tests. This is because e2e tests require several Kubernetes clusters and a Docker server so they are quite slow and hard to run in a development environment. We want to make sure that contributors can avoid the frustrating cycle of Commit, Push, Wait for CI, Realize it breaks, Repeat, so running tests quickly is very desirable. End-to-end tests also have the drawback that if they break the bug can be hard to track down. In summary, we prefer having granular tests for each library. This is why we have split the codebase into several libraries on GitHub . Each library has their own tests and own CI setup. When a library needs to interact with a different library we usually implement an interface with a well-described contract. This contract can then be used to write tests against. When it comes to actually writing the tests we follow the Detroit/classicist school of testing . Our tests are put in the separate _test package and test our code from the outside. Structuring your code \u00b6 In the early versions of ContainerSSH we had a rather monolithic application. The core SSH server would perform logging, write metrics, deal with SSH specifics, etc. Needless to say, writing and maintaining the code became very tedious. It took a a large amount of concentration to find the right parts to implement a change on, and finding bugs often took a slog through layers and layers of code. This is frustrating and hinders productivity. We don't want contributors to spend more time finding the right code piece than implementing the actual change. This requires a short-term sacrifice: better code structure and abstractions. Yes, we know, they are not fun to implement. When we refactored ContainerSSH in version 0.4 the size of the codebase grew by over 50%. However, this change was worth it as it paved the way for adding new features without pain in the future. Our aim is that each library or component should deal with one concern. The auth library should deal with authentication, the sshserver library with SSH, and so on. This goes so far that the integration work between two libraries is often relegated to a separate library. Sticking with the example before, the authintegration library creates a layer for the SSH server and calls the authentication library when user authentication is desired. There is no hard and fast rule what (not) to separate. Creating a prototype as a single library is fine. If it turns out that it is too unwieldy to test or use it can be refactored. Thankfully, we have no quarterly deadlines we need to hit, so a feature is released when it is ready. Third party libraries \u00b6 We group third party dependencies in two categories: primary and utility. Primary dependencies are the ones that are required to fulfil the primary function of a library. For example, the Docker libraries would be a primary dependency for the dockerrun library . These libraries are integrated directly. Needless to say, the libraries include component-level tests to verify the integration still works. This stands in contrast to utility libraries. For example, we use Yuki Iwanaga's defaults library to provide default values for structs in multiple ContainerSSH libraries. However, since the library may need to be replaced in the future we opt to create a wrapping layer called structutils . This wrapping layer describes our expectation towards the library and also includes tests to verify that this functionality still holds true. Dealing with networks \u00b6 ContainerSSH integrates several components that can be reached over the network, for example the config server, the auth server, or even Docker and Kubernetes. While in the development environment everything typically works fine, they can be notoriously unreliable in production. What's worse, these issues are extremely hard to debug, so we aim to prevent them. Our two choices of prevention are contexts and retries. Contexts in Go provide a graceful way to observe timeouts. The simplest way to create a timeout context is the following: ctx , cancelFunc := context . WithTimeout ( context . Background , 60 * time . Second , ) defer cancelFunc () Warning It is very important that you include the call to cancelFunc() otherwise you may leak memory. Now that you have a context you can check it inside a loop: loop : for { select { case <- ctx . Done (): break loop default : //Continue whatever you need to do } } Retries also come into play: when performing a call over the network you may encounter random errors you may wish to retry. We frequently couple the context with retries: var lastError error loop : for { lastError = someNetworkCall () if err == nil { break loop } else { logger . Warningf ( \"failed to perform network call, retrying in 10 seconds (%v)\" , lastError , ) } select { case <- ctx . Done (): break loop case <- time . After ( 10 * time . Second ): // Next loop } } if lastError != nil { logger . Errorf ( \"failed to perform network call, giving up (%v)\" , err ) return lastError } Microserviecs \u00b6 The above-mentioned networks also factor into the concept of microservices . ContainerSSH uses two external services for authentication and configuration . These are provided for user convenience making it easier to integrate ContainerSSH. However, we do not plan to add more microservices for development convenience. We want to avoid having more deployment YAML files than actual code. ContainerSSH should be simple to run, even if that means making it harder to structure the code. Conclusion \u00b6 We hope you now have a better idea of the design goals of ContainerSSH. However, it is worth reiterating: there is room for disagreement. If in doubt, feel free to submit a simple pull request and we'll work from there. If your solution is missing bits we'll work with you or even add missing code pieces to come to an agreeable solution.","title":"Coding Style"},{"location":"development/code-style/#object-oriented-programming","text":"Wait, what? OOP in Go? Yes, bear with me. Go has a concept called receivers that allow you to pass a context structure to a function. This is very similar to how private and public variables are handled in OOP languages. The main benefit of receivers is that they can be used to implement interfaces . Interfaces, in turn, give us the ability to create a standardized API between components without involving a network. The log library , for example, provides the Logger interface and then also includes an implementation for the logger. However, at no point do we have a hard dependency on the actual implementation of the logger. If in the future the implementation turns out to be insufficient replacing it is easy. We use this pattern extensively to separate the ContainerSSH libraries from each other. We are then using these interfaces to write tests for each library without having to run an end-to-end test for every test.","title":"Object-Oriented Programming"},{"location":"development/code-style/#testing","text":"This brings us to the topic of testing. ContainerSSH is a security-relevant software so we want to ensure a reasonable level of quality. In the beginning we had a manual testing protocol, but as features became more extensive it became very hard to test each feature for each release. We also rely on GitHub's Dependabot to update our external dependencies. Without tests we would have a very hard time verifying that the updated third party library did not break something. When it comes to test sizes we prefer having unit- or component-level tests and only have a few end-to-end tests. This is because e2e tests require several Kubernetes clusters and a Docker server so they are quite slow and hard to run in a development environment. We want to make sure that contributors can avoid the frustrating cycle of Commit, Push, Wait for CI, Realize it breaks, Repeat, so running tests quickly is very desirable. End-to-end tests also have the drawback that if they break the bug can be hard to track down. In summary, we prefer having granular tests for each library. This is why we have split the codebase into several libraries on GitHub . Each library has their own tests and own CI setup. When a library needs to interact with a different library we usually implement an interface with a well-described contract. This contract can then be used to write tests against. When it comes to actually writing the tests we follow the Detroit/classicist school of testing . Our tests are put in the separate _test package and test our code from the outside.","title":"Testing"},{"location":"development/code-style/#structuring-your-code","text":"In the early versions of ContainerSSH we had a rather monolithic application. The core SSH server would perform logging, write metrics, deal with SSH specifics, etc. Needless to say, writing and maintaining the code became very tedious. It took a a large amount of concentration to find the right parts to implement a change on, and finding bugs often took a slog through layers and layers of code. This is frustrating and hinders productivity. We don't want contributors to spend more time finding the right code piece than implementing the actual change. This requires a short-term sacrifice: better code structure and abstractions. Yes, we know, they are not fun to implement. When we refactored ContainerSSH in version 0.4 the size of the codebase grew by over 50%. However, this change was worth it as it paved the way for adding new features without pain in the future. Our aim is that each library or component should deal with one concern. The auth library should deal with authentication, the sshserver library with SSH, and so on. This goes so far that the integration work between two libraries is often relegated to a separate library. Sticking with the example before, the authintegration library creates a layer for the SSH server and calls the authentication library when user authentication is desired. There is no hard and fast rule what (not) to separate. Creating a prototype as a single library is fine. If it turns out that it is too unwieldy to test or use it can be refactored. Thankfully, we have no quarterly deadlines we need to hit, so a feature is released when it is ready.","title":"Structuring your code"},{"location":"development/code-style/#third-party-libraries","text":"We group third party dependencies in two categories: primary and utility. Primary dependencies are the ones that are required to fulfil the primary function of a library. For example, the Docker libraries would be a primary dependency for the dockerrun library . These libraries are integrated directly. Needless to say, the libraries include component-level tests to verify the integration still works. This stands in contrast to utility libraries. For example, we use Yuki Iwanaga's defaults library to provide default values for structs in multiple ContainerSSH libraries. However, since the library may need to be replaced in the future we opt to create a wrapping layer called structutils . This wrapping layer describes our expectation towards the library and also includes tests to verify that this functionality still holds true.","title":"Third party libraries"},{"location":"development/code-style/#dealing-with-networks","text":"ContainerSSH integrates several components that can be reached over the network, for example the config server, the auth server, or even Docker and Kubernetes. While in the development environment everything typically works fine, they can be notoriously unreliable in production. What's worse, these issues are extremely hard to debug, so we aim to prevent them. Our two choices of prevention are contexts and retries. Contexts in Go provide a graceful way to observe timeouts. The simplest way to create a timeout context is the following: ctx , cancelFunc := context . WithTimeout ( context . Background , 60 * time . Second , ) defer cancelFunc () Warning It is very important that you include the call to cancelFunc() otherwise you may leak memory. Now that you have a context you can check it inside a loop: loop : for { select { case <- ctx . Done (): break loop default : //Continue whatever you need to do } } Retries also come into play: when performing a call over the network you may encounter random errors you may wish to retry. We frequently couple the context with retries: var lastError error loop : for { lastError = someNetworkCall () if err == nil { break loop } else { logger . Warningf ( \"failed to perform network call, retrying in 10 seconds (%v)\" , lastError , ) } select { case <- ctx . Done (): break loop case <- time . After ( 10 * time . Second ): // Next loop } } if lastError != nil { logger . Errorf ( \"failed to perform network call, giving up (%v)\" , err ) return lastError }","title":"Dealing with networks"},{"location":"development/code-style/#microserviecs","text":"The above-mentioned networks also factor into the concept of microservices . ContainerSSH uses two external services for authentication and configuration . These are provided for user convenience making it easier to integrate ContainerSSH. However, we do not plan to add more microservices for development convenience. We want to avoid having more deployment YAML files than actual code. ContainerSSH should be simple to run, even if that means making it harder to structure the code.","title":"Microserviecs"},{"location":"development/code-style/#conclusion","text":"We hope you now have a better idea of the design goals of ContainerSSH. However, it is worth reiterating: there is room for disagreement. If in doubt, feel free to submit a simple pull request and we'll work from there. If your solution is missing bits we'll work with you or even add missing code pieces to come to an agreeable solution.","title":"Conclusion"},{"location":"development/dashboard/","text":"Development Dashboard Roadmap 0.4.0: Audit Logging \u00b6 This release will feature comprehensive audit logging . Add imagePullPolicy to dockerrun backend Multi-session containers Audit facility Integration tests Kubernetes backend does not display initial prompt Future \u00b6 This release collects all desired, but not scheduled features. Support WebAuthn SSH agent forwarding SSH port forwarding Keyboard-interactive authentication Web client Stopping ContainerSSH does not remove containers Ideas \u00b6 Ideas that are not sure to come. Kerberos/GSS-API authentication Direct shell backend SSH proxy backend PAM authentication Support Gitlab CI runners File manager Repositories Repository Description Version Commits since last version ContainerSSH ContainerSSH: Launch containers on demand 0.4.0-PR3 0 MiniContainerSSH A learning-focussed, simplified implementation of ContainerSSH 3 branding ContainerSSH icons, logos 15 containerssh.github.io The ContainerSSH website 146 auditlog Audit logger for ContainerSSH v0.9.8 0 log Common logging interface for ContainerSSH modules v0.9.9 0 sshserver The SSH server and decoding library used by ContainerSSH v0.9.16 3 library-template Template for library repositories 10 github-terraform Terraform repository for managing this GitHub organization 54 auditlogintegration Auditlog integration for the SSH server library v0.9.4 0 auth ContainerSSH authentication library v0.9.3 2 http Common HTTP library for ContainerSSH v0.9.5 0 authintegration SSH server integration of the auth library v0.9.2 0 configuration Common configuration library for ContainerSSH v0.9.7 0 geoip The GeoIP lookup library for ContainerSSH v0.9.4 0 metrics Metrics collection and server library for ContainerSSH v0.9.6 1 dockerrun The legacy Docker backend for ContainerSSH v0.9.2 6 backend Container backend abstraction library for ContainerSSH v0.9.7 0 kuberun The legacy Kubernetes backend for ContainerSSH v0.9.3 4 service Service layer for ContainerSSH v0.9.0 3 structutils Utility wrapper for structs for ContainerSSH v0.9.0 1 unixutils Utilities related to UNIX systems v0.9.0 0 AuthConfig The Authentication and Configuration Server for ContainerSSH 1 guest-image The source code of the default ContainerSSH guest image 12 kubernetes The Kubernetes backend for ContainerSSH v0.9.6 0 docker The Docker backend for ContainerSSH v0.9.8 0 agent The guest agent for ContainerSSH 0.9.3 0 security The security layer for ContainerSSH v0.9.6 0 metricsintegration SSH integration for metrics collection for ContainerSSH v0.9.2 0 packages The ContainerSSH packages page 37 Issues Repository Title Milestone Created ContainerSSH Support WebAuthn Future 5 days ago ContainerSSH Kerberos/GSS-API authentication Ideas 61 days ago ContainerSSH Direct shell backend Ideas 75 days ago ContainerSSH SSH proxy backend Ideas 75 days ago ContainerSSH PAM authentication Ideas 76 days ago ContainerSSH Support Gitlab CI runners Ideas 99 days ago ContainerSSH File manager Ideas 101 days ago ContainerSSH SSH agent forwarding Future 101 days ago ContainerSSH SSH port forwarding Future 101 days ago ContainerSSH Keyboard-interactive authentication Future 101 days ago ContainerSSH Web client Future 101 days ago ContainerSSH Stopping ContainerSSH does not remove containers Future 241 days ago github-terraform Automate label creation 57 days ago guest-image Implement Docker Trust 56 days ago Pull Requests Repository Title Created Mergeable Checks ContainerSSH Bump github.com/aws/aws-sdk-go from 1.36.27 to 1.37.5 2 days ago \u2705 \u274c ContainerSSH Bump github.com/docker/docker from 20.10.2+incompatible to 20.10.3+incompatible 5 days ago \u2705 \u274c auditlog Bump github.com/aws/aws-sdk-go from 1.36.27 to 1.37.5 2 days ago \u2705 \u2705 auditlog Bump github.com/docker/docker from 20.10.2+incompatible to 20.10.3+incompatible 5 days ago \u2705 \u2705 log Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 sshserver Bump github.com/google/uuid from 1.1.4 to 1.2.0 13 days ago \u2705 \u2705 sshserver Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 auditlogintegration Bump github.com/containerssh/auditlog from 0.9.7 to 0.9.8 20 days ago \u2705 \u2705 auth Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 auth Bump github.com/containerssh/log from 0.9.7 to 0.9.9 25 days ago \u2705 \u2705 auth Bump github.com/containerssh/http from 0.9.4 to 0.9.5 39 days ago \u2705 \u274c http Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 http Bump github.com/containerssh/log from 0.9.8 to 0.9.9 25 days ago \u2705 \u2705 authintegration Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 configuration Bump github.com/docker/docker from 20.10.1+incompatible to 20.10.3+incompatible 5 days ago \u2705 \u274c configuration Bump github.com/containerssh/sshserver from 0.9.14 to 0.9.16 24 days ago \u2705 \u274c configuration Bump github.com/containerssh/kubernetes from 0.9.5 to 0.9.6 25 days ago \u2705 \u274c configuration Bump github.com/containerssh/log from 0.9.8 to 0.9.9 25 days ago \u2705 \u2705 configuration Bump github.com/containerssh/docker from 0.9.7 to 0.9.8 25 days ago \u2705 \u274c geoip Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 metrics Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 metrics Bump github.com/containerssh/log from 0.9.8 to 0.9.9 25 days ago \u2705 \u2705 metrics Bump github.com/containerssh/geoip from 0.9.3 to 0.9.4 39 days ago \u2705 \u2705 kuberun Bump k8s.io/api from 0.20.0 to 0.20.1 48 days ago \u2705 \u274c kuberun Bump k8s.io/kubectl from 0.20.0 to 0.20.1 48 days ago \u2705 \u274c kuberun Bump k8s.io/apimachinery from 0.20.0 to 0.20.1 48 days ago \u2705 \u274c kuberun Bump k8s.io/client-go from 0.20.0 to 0.20.1 48 days ago \u2705 \u274c service Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 structutils Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 unixutils Bump github.com/mattn/go-shellwords from 1.0.10 to 1.0.11 20 days ago \u2705 \u2705 unixutils Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 kubernetes Bump k8s.io/api from 0.20.1 to 0.20.2 24 days ago \u2705 \u2705 kubernetes Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 kubernetes Bump github.com/containerssh/sshserver from 0.9.15 to 0.9.16 24 days ago \u2705 \u2705 kubernetes Bump k8s.io/client-go from 0.20.1 to 0.20.2 24 days ago \u2705 \u2705 kubernetes Bump k8s.io/apimachinery from 0.20.1 to 0.20.2 24 days ago \u2705 \u2705 docker Bump github.com/docker/docker from 20.10.2+incompatible to 20.10.3+incompatible 5 days ago \u2705 \u2705 docker Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u274c docker Bump github.com/containerssh/sshserver from 0.9.15 to 0.9.16 24 days ago \u2705 \u2705","title":"Dashboard"},{"location":"development/dashboard/#040-audit-logging","text":"This release will feature comprehensive audit logging . Add imagePullPolicy to dockerrun backend Multi-session containers Audit facility Integration tests Kubernetes backend does not display initial prompt","title":"0.4.0: Audit Logging"},{"location":"development/dashboard/#future","text":"This release collects all desired, but not scheduled features. Support WebAuthn SSH agent forwarding SSH port forwarding Keyboard-interactive authentication Web client Stopping ContainerSSH does not remove containers","title":"Future"},{"location":"development/dashboard/#ideas","text":"Ideas that are not sure to come. Kerberos/GSS-API authentication Direct shell backend SSH proxy backend PAM authentication Support Gitlab CI runners File manager Repositories Repository Description Version Commits since last version ContainerSSH ContainerSSH: Launch containers on demand 0.4.0-PR3 0 MiniContainerSSH A learning-focussed, simplified implementation of ContainerSSH 3 branding ContainerSSH icons, logos 15 containerssh.github.io The ContainerSSH website 146 auditlog Audit logger for ContainerSSH v0.9.8 0 log Common logging interface for ContainerSSH modules v0.9.9 0 sshserver The SSH server and decoding library used by ContainerSSH v0.9.16 3 library-template Template for library repositories 10 github-terraform Terraform repository for managing this GitHub organization 54 auditlogintegration Auditlog integration for the SSH server library v0.9.4 0 auth ContainerSSH authentication library v0.9.3 2 http Common HTTP library for ContainerSSH v0.9.5 0 authintegration SSH server integration of the auth library v0.9.2 0 configuration Common configuration library for ContainerSSH v0.9.7 0 geoip The GeoIP lookup library for ContainerSSH v0.9.4 0 metrics Metrics collection and server library for ContainerSSH v0.9.6 1 dockerrun The legacy Docker backend for ContainerSSH v0.9.2 6 backend Container backend abstraction library for ContainerSSH v0.9.7 0 kuberun The legacy Kubernetes backend for ContainerSSH v0.9.3 4 service Service layer for ContainerSSH v0.9.0 3 structutils Utility wrapper for structs for ContainerSSH v0.9.0 1 unixutils Utilities related to UNIX systems v0.9.0 0 AuthConfig The Authentication and Configuration Server for ContainerSSH 1 guest-image The source code of the default ContainerSSH guest image 12 kubernetes The Kubernetes backend for ContainerSSH v0.9.6 0 docker The Docker backend for ContainerSSH v0.9.8 0 agent The guest agent for ContainerSSH 0.9.3 0 security The security layer for ContainerSSH v0.9.6 0 metricsintegration SSH integration for metrics collection for ContainerSSH v0.9.2 0 packages The ContainerSSH packages page 37 Issues Repository Title Milestone Created ContainerSSH Support WebAuthn Future 5 days ago ContainerSSH Kerberos/GSS-API authentication Ideas 61 days ago ContainerSSH Direct shell backend Ideas 75 days ago ContainerSSH SSH proxy backend Ideas 75 days ago ContainerSSH PAM authentication Ideas 76 days ago ContainerSSH Support Gitlab CI runners Ideas 99 days ago ContainerSSH File manager Ideas 101 days ago ContainerSSH SSH agent forwarding Future 101 days ago ContainerSSH SSH port forwarding Future 101 days ago ContainerSSH Keyboard-interactive authentication Future 101 days ago ContainerSSH Web client Future 101 days ago ContainerSSH Stopping ContainerSSH does not remove containers Future 241 days ago github-terraform Automate label creation 57 days ago guest-image Implement Docker Trust 56 days ago Pull Requests Repository Title Created Mergeable Checks ContainerSSH Bump github.com/aws/aws-sdk-go from 1.36.27 to 1.37.5 2 days ago \u2705 \u274c ContainerSSH Bump github.com/docker/docker from 20.10.2+incompatible to 20.10.3+incompatible 5 days ago \u2705 \u274c auditlog Bump github.com/aws/aws-sdk-go from 1.36.27 to 1.37.5 2 days ago \u2705 \u2705 auditlog Bump github.com/docker/docker from 20.10.2+incompatible to 20.10.3+incompatible 5 days ago \u2705 \u2705 log Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 sshserver Bump github.com/google/uuid from 1.1.4 to 1.2.0 13 days ago \u2705 \u2705 sshserver Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 auditlogintegration Bump github.com/containerssh/auditlog from 0.9.7 to 0.9.8 20 days ago \u2705 \u2705 auth Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 auth Bump github.com/containerssh/log from 0.9.7 to 0.9.9 25 days ago \u2705 \u2705 auth Bump github.com/containerssh/http from 0.9.4 to 0.9.5 39 days ago \u2705 \u274c http Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 http Bump github.com/containerssh/log from 0.9.8 to 0.9.9 25 days ago \u2705 \u2705 authintegration Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 configuration Bump github.com/docker/docker from 20.10.1+incompatible to 20.10.3+incompatible 5 days ago \u2705 \u274c configuration Bump github.com/containerssh/sshserver from 0.9.14 to 0.9.16 24 days ago \u2705 \u274c configuration Bump github.com/containerssh/kubernetes from 0.9.5 to 0.9.6 25 days ago \u2705 \u274c configuration Bump github.com/containerssh/log from 0.9.8 to 0.9.9 25 days ago \u2705 \u2705 configuration Bump github.com/containerssh/docker from 0.9.7 to 0.9.8 25 days ago \u2705 \u274c geoip Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 metrics Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 metrics Bump github.com/containerssh/log from 0.9.8 to 0.9.9 25 days ago \u2705 \u2705 metrics Bump github.com/containerssh/geoip from 0.9.3 to 0.9.4 39 days ago \u2705 \u2705 kuberun Bump k8s.io/api from 0.20.0 to 0.20.1 48 days ago \u2705 \u274c kuberun Bump k8s.io/kubectl from 0.20.0 to 0.20.1 48 days ago \u2705 \u274c kuberun Bump k8s.io/apimachinery from 0.20.0 to 0.20.1 48 days ago \u2705 \u274c kuberun Bump k8s.io/client-go from 0.20.0 to 0.20.1 48 days ago \u2705 \u274c service Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 structutils Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 unixutils Bump github.com/mattn/go-shellwords from 1.0.10 to 1.0.11 20 days ago \u2705 \u2705 unixutils Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 kubernetes Bump k8s.io/api from 0.20.1 to 0.20.2 24 days ago \u2705 \u2705 kubernetes Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u2705 kubernetes Bump github.com/containerssh/sshserver from 0.9.15 to 0.9.16 24 days ago \u2705 \u2705 kubernetes Bump k8s.io/client-go from 0.20.1 to 0.20.2 24 days ago \u2705 \u2705 kubernetes Bump k8s.io/apimachinery from 0.20.1 to 0.20.2 24 days ago \u2705 \u2705 docker Bump github.com/docker/docker from 20.10.2+incompatible to 20.10.3+incompatible 5 days ago \u2705 \u2705 docker Bump github.com/stretchr/testify from 1.6.1 to 1.7.0 24 days ago \u2705 \u274c docker Bump github.com/containerssh/sshserver from 0.9.15 to 0.9.16 24 days ago \u2705 \u2705","title":"Ideas"},{"location":"development/getting-started/","text":"Getting started with ContainerSSH development Welcome to developing ContainerSSH! For the purposes of this guide we will assume you have your development environment set up and ready to go . If not, please follow our handy guide to do just that . Ready? Good. Cloning the repository \u00b6 Before we begin you will have to decide what you want to do. If you just want to get ContainerSSH running to get the big picture you will need to clone the ContainerSSH/ContainerSSH repository . This contains the main ContainerSSH executable, as well as the Auth-Config server used for testing: git clone https://github.com/containerssh/containerssh However, ContainerSSH is built in a highly modular fashion so you may need to change a specific library. You can find the list of libraries on our development dashboard . This dashboard contains an overview of all repositories, issues, pull requests, and everything else you will need to find your way around the codebase. Each repository contains a readme explaining how to use that specific component. If you find the readme not helpful please open an issue on that repository asking for more information. If you find yourself needing a new repository because you want to develop something completely new please file a pull request against the github-terraform repository. Tip For the best results we recommend cloning the ContainerSSH repos into /path/to/your/home/go/src/github.com/containerssh/REPONAME . Running ContainerSSH \u00b6 Running ContainerSSH is simple. You will need a clone of the main ContainerSSH repository. Then you have to run two commands. First, the auth-config server needs to be run from the cmd/containerssh-testauthconfigserver directory: go run . When that's running create the cmd/containerssh/config.yaml file with the following content: --- log : level : debug ssh : hostkeys : - ssh_host_rsa_key backend : dockerrun auth : url : \"http://127.0.0.1:8080\" pubkey : false configserver : url : \"http://127.0.0.1:8080/config\" Now copy the ssh_host_rsa_key file from the example folder and then run ContainerSSH from the cmd/containerssh folder: go run . --config config.yaml That's it! Now you have a running ContainerSSH you can connect to on port 2222: ssh foo@localhost -p 2222 Running the tests \u00b6 There are two types of tests for ContainerSSH: end to end tests and component-level tests. Both can be run using the following command from each library's main folder: go test ./... Tip Some tests require a working Docker or Kubernetes backend. Make sure that your Docker socket is running on your platform default and your Kubernetes configuration is available in the .kube/config file in your home directory as the tests will use these to connect to. Submitting a pull requests \u00b6 Once you are done with your development you should fork the repository on GitHub and create a pull request . This pull request will automatically be tested by the CI system. Feel free to keep working on your PR until you are happy with it. Understanding ContainerSSH \u00b6 ContainerSSH is a reasonably complex piece of software. It uses the built-in Go SSH library to create a server and the client libraries for Docker and Kubernetes to forward the data from the SSH channel to the standard input and output of the container. We have dedicated a whole section to understanding how SSH and ContainerSSH in particular work.","title":"Getting Started"},{"location":"development/getting-started/#cloning-the-repository","text":"Before we begin you will have to decide what you want to do. If you just want to get ContainerSSH running to get the big picture you will need to clone the ContainerSSH/ContainerSSH repository . This contains the main ContainerSSH executable, as well as the Auth-Config server used for testing: git clone https://github.com/containerssh/containerssh However, ContainerSSH is built in a highly modular fashion so you may need to change a specific library. You can find the list of libraries on our development dashboard . This dashboard contains an overview of all repositories, issues, pull requests, and everything else you will need to find your way around the codebase. Each repository contains a readme explaining how to use that specific component. If you find the readme not helpful please open an issue on that repository asking for more information. If you find yourself needing a new repository because you want to develop something completely new please file a pull request against the github-terraform repository. Tip For the best results we recommend cloning the ContainerSSH repos into /path/to/your/home/go/src/github.com/containerssh/REPONAME .","title":"Cloning the repository"},{"location":"development/getting-started/#running-containerssh","text":"Running ContainerSSH is simple. You will need a clone of the main ContainerSSH repository. Then you have to run two commands. First, the auth-config server needs to be run from the cmd/containerssh-testauthconfigserver directory: go run . When that's running create the cmd/containerssh/config.yaml file with the following content: --- log : level : debug ssh : hostkeys : - ssh_host_rsa_key backend : dockerrun auth : url : \"http://127.0.0.1:8080\" pubkey : false configserver : url : \"http://127.0.0.1:8080/config\" Now copy the ssh_host_rsa_key file from the example folder and then run ContainerSSH from the cmd/containerssh folder: go run . --config config.yaml That's it! Now you have a running ContainerSSH you can connect to on port 2222: ssh foo@localhost -p 2222","title":"Running ContainerSSH"},{"location":"development/getting-started/#running-the-tests","text":"There are two types of tests for ContainerSSH: end to end tests and component-level tests. Both can be run using the following command from each library's main folder: go test ./... Tip Some tests require a working Docker or Kubernetes backend. Make sure that your Docker socket is running on your platform default and your Kubernetes configuration is available in the .kube/config file in your home directory as the tests will use these to connect to.","title":"Running the tests"},{"location":"development/getting-started/#submitting-a-pull-requests","text":"Once you are done with your development you should fork the repository on GitHub and create a pull request . This pull request will automatically be tested by the CI system. Feel free to keep working on your PR until you are happy with it.","title":"Submitting a pull requests"},{"location":"development/getting-started/#understanding-containerssh","text":"ContainerSSH is a reasonably complex piece of software. It uses the built-in Go SSH library to create a server and the client libraries for Docker and Kubernetes to forward the data from the SSH channel to the standard input and output of the container. We have dedicated a whole section to understanding how SSH and ContainerSSH in particular work.","title":"Understanding ContainerSSH"},{"location":"development/releases/","text":"Creating releases Once the code is written it comes to creating a release. This document will cover how a release is created, both for libraries and applications Versioning \u00b6 When heading up to a release versioning must be kept in mind. We follow SemVer , so only major versions may contain breaking changes. The only exception is versions before 1.0.0 , these may break in minor versions too. For applications we aim to support a major version as long as feasible. We do not want to break configuration file formats, backend features, protocols, etc. unless it is absolutely unavoidable. However, such a guarantee is not made for libraries. Our libraries are primarily intended for consumption by ContainerSSH, so we may decide to bump the major version at any time. We have to keep in mind, however, that bumping a major version of a library means that all depending libraries will need to be updated. Release notes \u00b6 Once the main branch is ready for release the last step is writing release notes. We do not follow the concept of simply listing the commits, we aim to write human-readable release notes that explain the changes. The explanation has to be detailed enough so anyone from the target audience can understand what is changing without needing to understand the implementation. The release notes should be added to CHANGELOG.md . Creating a release \u00b6 The day has finally come: the release notes and codes are in, tests are passing. Now we need to create a release. We do this exclusively from the GitHub interface. We name versions for libraries in the format of v1.2.3 so Go can pull them in, while applications are named 1.2.3 to avoid pulling them in from a Go program. We copy the name and description from the CHANGELOG.md into the release notes on GitHub. For applications the release mechanism will create and upload the binaries. Once this process is complete we announce the release on the public channels.","title":"Releases"},{"location":"development/releases/#versioning","text":"When heading up to a release versioning must be kept in mind. We follow SemVer , so only major versions may contain breaking changes. The only exception is versions before 1.0.0 , these may break in minor versions too. For applications we aim to support a major version as long as feasible. We do not want to break configuration file formats, backend features, protocols, etc. unless it is absolutely unavoidable. However, such a guarantee is not made for libraries. Our libraries are primarily intended for consumption by ContainerSSH, so we may decide to bump the major version at any time. We have to keep in mind, however, that bumping a major version of a library means that all depending libraries will need to be updated.","title":"Versioning"},{"location":"development/releases/#release-notes","text":"Once the main branch is ready for release the last step is writing release notes. We do not follow the concept of simply listing the commits, we aim to write human-readable release notes that explain the changes. The explanation has to be detailed enough so anyone from the target audience can understand what is changing without needing to understand the implementation. The release notes should be added to CHANGELOG.md .","title":"Release notes"},{"location":"development/releases/#creating-a-release","text":"The day has finally come: the release notes and codes are in, tests are passing. Now we need to create a release. We do this exclusively from the GitHub interface. We name versions for libraries in the format of v1.2.3 so Go can pull them in, while applications are named 1.2.3 to avoid pulling them in from a Go program. We copy the name and description from the CHANGELOG.md into the release notes on GitHub. For applications the release mechanism will create and upload the binaries. Once this process is complete we announce the release on the public channels.","title":"Creating a release"},{"location":"development/containerssh/","text":"Understanding ContainerSSH ContainerSSH is an SSH server that talks to external APIs such as Docker or Kubernetes. This section will explain how ContainerSSH is built. Understanding SSH \u00b6 We don't really think about SSH all that much. Open PuTTY, or your terminal, SSH into a server, and merrily type commands issued to a server running a distance away. Except if you need to write an SSH server. This section will discuss the concepts you need to work on ContainerSSH. Read more \u00bb Your first SSH server \u00b6 ContainerSSH may be complex, so let's start simple: let's implement a very simple SSH server in Go that talks to the Docker backend. Read more \u00bb Internal Architecture \u00b6 ContainerSSH is a project of several thousand lines of code so overview is critical. Our internal architecture document describes what the moving parts of ContainerSSH are. Read more \u00bb","title":"Overview"},{"location":"development/containerssh/#understanding-ssh","text":"We don't really think about SSH all that much. Open PuTTY, or your terminal, SSH into a server, and merrily type commands issued to a server running a distance away. Except if you need to write an SSH server. This section will discuss the concepts you need to work on ContainerSSH. Read more \u00bb","title":"Understanding SSH"},{"location":"development/containerssh/#your-first-ssh-server","text":"ContainerSSH may be complex, so let's start simple: let's implement a very simple SSH server in Go that talks to the Docker backend. Read more \u00bb","title":"Your first SSH server"},{"location":"development/containerssh/#internal-architecture","text":"ContainerSSH is a project of several thousand lines of code so overview is critical. Our internal architecture document describes what the moving parts of ContainerSSH are. Read more \u00bb","title":"Internal Architecture"},{"location":"development/containerssh/first-ssh-server/","text":"Implementing your first SSH server This section will guide you through implementing your first SSH server in go and combine it with Docker. Tip If you are new to SSH development please read our Understanding SSH guide first. Tip The source code for this mini project is available on GitHub . Step 1: The basic loop \u00b6 Let's start off easy: implementing a TCP server. On *NIX systems listen sockets can be started using the listen() system call and Go follows that pattern nicely: listener , err := net . Listen ( \"tcp\" , \"0.0.0.0:2222\" ) However, net.Listen does not accept connections, it merely opens a listen socket telling the system kernel that it should not reject connections coming to the specified port. Now we need to accept any incoming connections. Let's do that: tcpConn , err := listener . Accept () This call will block until a client connects or the listen socket is closed. Let's ignore the second case and focus on the first. With tcpConn we now have an open plain text TCP connection. We can read from it, we can write to it, but until we call listener.Accept() again we won't get any new connections. So let's put it in a loop: for { tcpConn , err := listener . Accept () } Cool, so now we can accept multiple connections! However, these are still just plain text connections, so let's make them into an SSH connection: sshConn , chans , reqs , err := ssh . NewServerConn ( tcpConn , sshConfig ) We won't go into the details of sshConfig here, let's focus on the returned variables instead. The first returned variable, sshConn is the raw SSH connection. If you use an IDE you can use code completion to figure out some useful methods it contains, for example for closing the connection. More interesting to us are the chans and reqs variables, however. The chans variable contains a Go channel containing SSH channel request. When a client wants to open a new channel we can read from this Go channel and process the request. (Confusing, we know, two things with the same name.) The reqs variable is also a Go channel, but it contains global requests. We won't deal with these now, so let's disregard these completely: go ssh . DiscardRequests ( reqs ) As you can see we used the go keyword. This is running the method called in a goroutine . If you are coming from another programming language you can imagine these as multi-threaded coroutines. Suffice it to say, they won't block our main loop. Back to the chans , let's deal with them too. Let's handle them in a method called handleChannels : go handleChannels ( sshConn , chans ) This method will be rather simple: func handleChannels ( conn * ssh . ServerConn , chans <- chan ssh . NewChannel ) { for newChannel := range chans { go handleChannel ( conn , newChannel ) } } For each new channel we open yet another goroutine. Fear not, goroutines are very cheap in Go. Let's deal with that channel: func handleChannel ( conn * ssh . ServerConn , newChannel ssh . NewChannel ) { if t := newChannel . ChannelType (); t != \"session\" { _ = newChannel . Reject ( ssh . UnknownChannelType , fmt . Sprintf ( \"unknown channel type: %s\" , t )) return } channel , requests , err := newChannel . Accept () //... } So far so good, we reject all non-session channels and otherwise accept. The channel contains the reference to the channel, which is also an io.Reader and an io.Writer for stdin and stdout . The requests variable is a go channel containing SSH channel-specific requests. Now, let's use Docker as our backend. It's simple and it's really well documented . On a *NIX system we can create a Docker client like this: docker , err := client . NewClient ( \"unix:///var/run/docker.sock\" , nil , make ( map [ string ] string ), ) Now we can loop over the requests and handle them, one by one: for req := range requests { reply := func ( success bool , message [] byte ) { if req . WantReply { err := req . Reply ( success , message ) if err != nil { closeConnections () } } } handleRequest ( //... ) } As you can see, the requests may need a reply, so we are constructing a simplified function to send a reply back to the SSH client. For the final piece of our puzzle, let's implement the handleRequest method. For simplicity let's implement a switch-case: switch req . Type { case \"env\" : // Save environment variables for later use case \"pty-req\" : // Set the TTY flag on the Docker client to true later case \"window-change\" : // Use the ContainerResize method on the Docker client later case \"shell\" : // Create a container and run it case \"exec\" : // Create a container and run it } That's it! You can find the details on how to run a container in our highly simplified minicontainerssh example . We have skipped many parts like error handling, but it should give you a good overview of how an SSH server in Go works and how it interacts with the container backend. Now you are ready to dive into the internal architecture of ContainerSSH .","title":"Writing your first SSH server"},{"location":"development/containerssh/first-ssh-server/#step-1-the-basic-loop","text":"Let's start off easy: implementing a TCP server. On *NIX systems listen sockets can be started using the listen() system call and Go follows that pattern nicely: listener , err := net . Listen ( \"tcp\" , \"0.0.0.0:2222\" ) However, net.Listen does not accept connections, it merely opens a listen socket telling the system kernel that it should not reject connections coming to the specified port. Now we need to accept any incoming connections. Let's do that: tcpConn , err := listener . Accept () This call will block until a client connects or the listen socket is closed. Let's ignore the second case and focus on the first. With tcpConn we now have an open plain text TCP connection. We can read from it, we can write to it, but until we call listener.Accept() again we won't get any new connections. So let's put it in a loop: for { tcpConn , err := listener . Accept () } Cool, so now we can accept multiple connections! However, these are still just plain text connections, so let's make them into an SSH connection: sshConn , chans , reqs , err := ssh . NewServerConn ( tcpConn , sshConfig ) We won't go into the details of sshConfig here, let's focus on the returned variables instead. The first returned variable, sshConn is the raw SSH connection. If you use an IDE you can use code completion to figure out some useful methods it contains, for example for closing the connection. More interesting to us are the chans and reqs variables, however. The chans variable contains a Go channel containing SSH channel request. When a client wants to open a new channel we can read from this Go channel and process the request. (Confusing, we know, two things with the same name.) The reqs variable is also a Go channel, but it contains global requests. We won't deal with these now, so let's disregard these completely: go ssh . DiscardRequests ( reqs ) As you can see we used the go keyword. This is running the method called in a goroutine . If you are coming from another programming language you can imagine these as multi-threaded coroutines. Suffice it to say, they won't block our main loop. Back to the chans , let's deal with them too. Let's handle them in a method called handleChannels : go handleChannels ( sshConn , chans ) This method will be rather simple: func handleChannels ( conn * ssh . ServerConn , chans <- chan ssh . NewChannel ) { for newChannel := range chans { go handleChannel ( conn , newChannel ) } } For each new channel we open yet another goroutine. Fear not, goroutines are very cheap in Go. Let's deal with that channel: func handleChannel ( conn * ssh . ServerConn , newChannel ssh . NewChannel ) { if t := newChannel . ChannelType (); t != \"session\" { _ = newChannel . Reject ( ssh . UnknownChannelType , fmt . Sprintf ( \"unknown channel type: %s\" , t )) return } channel , requests , err := newChannel . Accept () //... } So far so good, we reject all non-session channels and otherwise accept. The channel contains the reference to the channel, which is also an io.Reader and an io.Writer for stdin and stdout . The requests variable is a go channel containing SSH channel-specific requests. Now, let's use Docker as our backend. It's simple and it's really well documented . On a *NIX system we can create a Docker client like this: docker , err := client . NewClient ( \"unix:///var/run/docker.sock\" , nil , make ( map [ string ] string ), ) Now we can loop over the requests and handle them, one by one: for req := range requests { reply := func ( success bool , message [] byte ) { if req . WantReply { err := req . Reply ( success , message ) if err != nil { closeConnections () } } } handleRequest ( //... ) } As you can see, the requests may need a reply, so we are constructing a simplified function to send a reply back to the SSH client. For the final piece of our puzzle, let's implement the handleRequest method. For simplicity let's implement a switch-case: switch req . Type { case \"env\" : // Save environment variables for later use case \"pty-req\" : // Set the TTY flag on the Docker client to true later case \"window-change\" : // Use the ContainerResize method on the Docker client later case \"shell\" : // Create a container and run it case \"exec\" : // Create a container and run it } That's it! You can find the details on how to run a container in our highly simplified minicontainerssh example . We have skipped many parts like error handling, but it should give you a good overview of how an SSH server in Go works and how it interacts with the container backend. Now you are ready to dive into the internal architecture of ContainerSSH .","title":"Step 1: The basic loop"},{"location":"development/containerssh/internal-architecture/","text":"Internal Architecture The ContainerSSH internal architecture consists of two main parts: the SSH server and the backends. The SSH server is located in the github.com/containerssh/containerssh/ssh . The server can be instantiated using the NewServer() method. This method will take an implementation of the authentication client that is performing the authentication. The interface for the client is defined in github.com/containerssh/containerssh/auth . It must implement two methods for password and public key authentication. It will also take a client implementation for the configuration. The interface is defined in github.com/containerssh/containerssh/config/client . It must implement a single method to fetch the configuration. The final significant method is the backend registry. The backend is fetched based on the configuration in the config file or from the config server. The backend is a structure of Backend defined in github.com/containerssh/containerssh/backend/ . The CreateSession method takes the details of the current connection and returns a session implementation. The session implementation defines the handler methods for individual SSH events like setting environment variables or executing commands.","title":"Internal Architecture"},{"location":"development/containerssh/ssh/","text":"Understanding SSH Let's face it: we don't think about SSH all that much. We SSH into a server and merrily type away our commands. Until we need to write an SSH server. This document describes the high level concepts of SSH: how do you open a connection, what are channels, and how do requests work. This is a very high level overview, but should contain everything you need to get started with ContainerSSH development. Handshake \u00b6 When the user connects an SSH server the SSH keys are verified. We won't discuss this here as for ContainerSSH the Go SSH library takes care of that. The first thing we are concerned with is authentication. Authentication is described by RFC 4252 and it states the following: The server drives the authentication by telling the client which authentication methods can be used to continue the exchange at any given time. The client has the freedom to try the methods listed by the server in any order. In other words, when the user connects the SSH server tells the client which authentication method it supports. The client picks one of them and performs the authentication. The server can then decide to reject, allow, or show the client another list of methods (e.g. to perform two factor authentication). The Go library vastly simplifies this process and only allows a single means of authentication for each connection. Each authentication request contains a username. The username may change between authentication attempts to authenticate against different systems, but this is not customary. Connection \u00b6 Once the authentication is complete the connection is open and both the client and the server may now send two types of messages: global requests and channels . Global requests describe requests in either direction that one party wants from the other. For example, the OpenSSH extensions describe the no-more-sessions@openssh.com to indicate that no more session channels should be opened on this connection. The channels, on the other hand are means of transporting data. For example, the session channel is responsible for executing a program and then transporting the standard input, output, and error data streams to and from the program. They also give both ends the ability to send channel-specific requests (e.g. setting environment variables, resizing the window, etc.). Session channels \u00b6 While there are theoretically other types of channels possible, we currently only support session channels. The client can request channels to be opened at any time. We currently support the following requests on the session channel. These are described in RFC 4254 . env Sets an environment variable for the soon to be executed program. pty Requests an interactive terminal for user input. shell Requests the default shell to be executed. exec Requests a specific program to be executed. subsystem Requests a well-known subsystem (e.g. sftp ) to be executed. window-change Informs the server that an interactive terminal window has changed size. This is only sent once the program has been started with the requests above. signal Requests the server to send a signal to the currently running process. In addition, we also send an exit-status request to the client from the server when the program exits to inform the client of the exit code. Interactive terminals \u00b6 As you can see above, the user can request an interactive terminal using the pty request. This is done automatically by SSH clients if they detect that their input is an interactive terminal. Using interactive terminals changes the operation mode of stdin, stdout, and stderr. While programs normally write their standard output to stdout and their error output to stderr , programs running in interactive mode send their combined output to stdout using a special framing. (TTY multiplexing) Thankfully, we don't need to know too much about TTY multiplexing for writing an SSH server since it is transparently passed through from the container engine to the SSH channel and we don't interact with it. RFCs \u00b6 The SSH protocol is governed by the following RFCs: RFC 913: Simple File Transfer Protocol This document describes the SFTP protocol used over SSH. RFC 4250: The Secure Shell (SSH) Protocol Assigned Numbers This document describes the protocol numbers and standard constants used in SSH. RFC 4251: The Secure Shell (SSH) Protocol Architecture This document describes the design decisions taken to work with SSH. RFC 4252: The Secure Shell (SSH) Authentication Protocol This document describes how user authentication works in SSH. RFC 4253: The Secure Shell (SSH) Transport Layer Protocol This document describes the details of how data is transported over SSH. RFC 4254: The Secure Shell (SSH) Connection Protocol This document contains the parts most interesting to us: how channels, sessions, etc. work. RFC 4255: Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints This document describes how to publish SSH fingerprints using DNS. It has not seen wide adoption. RFC 4256: Generic Message Exchange Authentication for the Secure Shell Protocol (SSH) This document describes the keyboard-interactive authentication for SSH, which is often used for two factor authentication. RFC 4335: The Secure Shell (SSH) Session Channel Break Extension This document describes the telnet-compatible break request for use in SSH. RFC 4344 , RFC 4345 , RFC 4419 , RFC 4432 These documents describe various encryption-related topics. RFC 4462: Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol This document describes the GSS-API authentication method that can be used to authenticate with a Kerberos ticket. RFC 4716: The Secure Shell (SSH) Public Key File Format This document describes the PEM-like format to store SSH keys in. RFC 4819: Secure Shell Public Key Subsystem This document describes the SSH public key subsystem usable for adding, removing, and listing public keys. RFC 5647 , RFC 5656 , RFC 6187 , RFC 6239 , RFC 6594 , RFC 6668 These documents describe various cryptography and authentication related topics. RFC 7479: Using Ed25519 in SSHFP Resource Records This document describes publishing ED25519 host keys using DNS. RFC 5592: Secure Shell Transport Model for the Simple Network Management Protocol (SNMP) This protocol describes using SNMP over SSH. RFC 6242: Using the NETCONF Protocol over Secure Shell (SSH) This document describes transporting the RFC 6241 Network Configuration Protocol over SSH. This can be used to manage networking equipment. In addition, OpenSSH defines the following extensions: The OpenSSH Protocol This document describes new cryptographic methods, tunnel forwarding, domain socket forwarding, and many more changes. The CertKeys Document This document describes the OpenSSH CA method. SSH Agent Protocol Describes the protocol used by the SSH agent holding the SSH keys in escrow.","title":"Understanding SSH"},{"location":"development/containerssh/ssh/#handshake","text":"When the user connects an SSH server the SSH keys are verified. We won't discuss this here as for ContainerSSH the Go SSH library takes care of that. The first thing we are concerned with is authentication. Authentication is described by RFC 4252 and it states the following: The server drives the authentication by telling the client which authentication methods can be used to continue the exchange at any given time. The client has the freedom to try the methods listed by the server in any order. In other words, when the user connects the SSH server tells the client which authentication method it supports. The client picks one of them and performs the authentication. The server can then decide to reject, allow, or show the client another list of methods (e.g. to perform two factor authentication). The Go library vastly simplifies this process and only allows a single means of authentication for each connection. Each authentication request contains a username. The username may change between authentication attempts to authenticate against different systems, but this is not customary.","title":"Handshake"},{"location":"development/containerssh/ssh/#connection","text":"Once the authentication is complete the connection is open and both the client and the server may now send two types of messages: global requests and channels . Global requests describe requests in either direction that one party wants from the other. For example, the OpenSSH extensions describe the no-more-sessions@openssh.com to indicate that no more session channels should be opened on this connection. The channels, on the other hand are means of transporting data. For example, the session channel is responsible for executing a program and then transporting the standard input, output, and error data streams to and from the program. They also give both ends the ability to send channel-specific requests (e.g. setting environment variables, resizing the window, etc.).","title":"Connection"},{"location":"development/containerssh/ssh/#session-channels","text":"While there are theoretically other types of channels possible, we currently only support session channels. The client can request channels to be opened at any time. We currently support the following requests on the session channel. These are described in RFC 4254 . env Sets an environment variable for the soon to be executed program. pty Requests an interactive terminal for user input. shell Requests the default shell to be executed. exec Requests a specific program to be executed. subsystem Requests a well-known subsystem (e.g. sftp ) to be executed. window-change Informs the server that an interactive terminal window has changed size. This is only sent once the program has been started with the requests above. signal Requests the server to send a signal to the currently running process. In addition, we also send an exit-status request to the client from the server when the program exits to inform the client of the exit code.","title":"Session channels"},{"location":"development/containerssh/ssh/#interactive-terminals","text":"As you can see above, the user can request an interactive terminal using the pty request. This is done automatically by SSH clients if they detect that their input is an interactive terminal. Using interactive terminals changes the operation mode of stdin, stdout, and stderr. While programs normally write their standard output to stdout and their error output to stderr , programs running in interactive mode send their combined output to stdout using a special framing. (TTY multiplexing) Thankfully, we don't need to know too much about TTY multiplexing for writing an SSH server since it is transparently passed through from the container engine to the SSH channel and we don't interact with it.","title":"Interactive terminals"},{"location":"development/containerssh/ssh/#rfcs","text":"The SSH protocol is governed by the following RFCs: RFC 913: Simple File Transfer Protocol This document describes the SFTP protocol used over SSH. RFC 4250: The Secure Shell (SSH) Protocol Assigned Numbers This document describes the protocol numbers and standard constants used in SSH. RFC 4251: The Secure Shell (SSH) Protocol Architecture This document describes the design decisions taken to work with SSH. RFC 4252: The Secure Shell (SSH) Authentication Protocol This document describes how user authentication works in SSH. RFC 4253: The Secure Shell (SSH) Transport Layer Protocol This document describes the details of how data is transported over SSH. RFC 4254: The Secure Shell (SSH) Connection Protocol This document contains the parts most interesting to us: how channels, sessions, etc. work. RFC 4255: Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints This document describes how to publish SSH fingerprints using DNS. It has not seen wide adoption. RFC 4256: Generic Message Exchange Authentication for the Secure Shell Protocol (SSH) This document describes the keyboard-interactive authentication for SSH, which is often used for two factor authentication. RFC 4335: The Secure Shell (SSH) Session Channel Break Extension This document describes the telnet-compatible break request for use in SSH. RFC 4344 , RFC 4345 , RFC 4419 , RFC 4432 These documents describe various encryption-related topics. RFC 4462: Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol This document describes the GSS-API authentication method that can be used to authenticate with a Kerberos ticket. RFC 4716: The Secure Shell (SSH) Public Key File Format This document describes the PEM-like format to store SSH keys in. RFC 4819: Secure Shell Public Key Subsystem This document describes the SSH public key subsystem usable for adding, removing, and listing public keys. RFC 5647 , RFC 5656 , RFC 6187 , RFC 6239 , RFC 6594 , RFC 6668 These documents describe various cryptography and authentication related topics. RFC 7479: Using Ed25519 in SSHFP Resource Records This document describes publishing ED25519 host keys using DNS. RFC 5592: Secure Shell Transport Model for the Simple Network Management Protocol (SNMP) This protocol describes using SNMP over SSH. RFC 6242: Using the NETCONF Protocol over Secure Shell (SSH) This document describes transporting the RFC 6241 Network Configuration Protocol over SSH. This can be used to manage networking equipment. In addition, OpenSSH defines the following extensions: The OpenSSH Protocol This document describes new cryptographic methods, tunnel forwarding, domain socket forwarding, and many more changes. The CertKeys Document This document describes the OpenSSH CA method. SSH Agent Protocol Describes the protocol used by the SSH agent holding the SSH keys in escrow.","title":"RFCs"},{"location":"development/devenv/","text":"Setting up your development environment Welcome! This guide will help you set up your development environment for writing ContainerSSH code. We recommend to following this guide step by step, even when you have already set up some of them yourself. Step 1: Create a GitHub account \u00b6 ContainerSSH development is exclusively handled on GitHub. In order to send code or website contributions you will need to create a GitHub account . Once you have an account we also recommend setting up two-factor authentication . Step 2: Installing Git \u00b6 Unless you plan to develop exclusively on the GitHub web interface you will also need to install Git on your computer. We support development on Windows, Linux, and MacOS, feel free to use any of those operating systems. Please follow the GitHub guide to install Git on your operating system. Step 3: Creating a GPG key \u00b6 Git is a distributed versioning system and you can make commits in the name of others. In order to verify committer identity (for both security and licencing purposes) we require all commits to be signed using GPG. Please follow our GPG for Git guide to enable code signing on your machine.. Step 4: Installing Golang \u00b6 To compile the code you will need Golang. We have a guide to install Golang on various platforms. Step 5: Installing the QA tools \u00b6 To make sure there are no latent errors are creeping in we are using some QA tools you will need . Step 6: Installing Docker \u00b6 The dockerrun backend requires Docker to be installed. Please install Docker to develop against. Step 7: Installing Kubernetes \u00b6 The kuberun backend requires Kubernetes to be installed. Please install a lightweight Kubernetes to develop against. Step 8: Setting up your IDE \u00b6 We have a guide to set up VSCode and Goland as your IDE. Step 9: Website \u00b6 This website requires a Python to run locally . This guide explains the details of setting it up.","title":"Overview"},{"location":"development/devenv/#step-1-create-a-github-account","text":"ContainerSSH development is exclusively handled on GitHub. In order to send code or website contributions you will need to create a GitHub account . Once you have an account we also recommend setting up two-factor authentication .","title":"Step 1: Create a GitHub account"},{"location":"development/devenv/#step-2-installing-git","text":"Unless you plan to develop exclusively on the GitHub web interface you will also need to install Git on your computer. We support development on Windows, Linux, and MacOS, feel free to use any of those operating systems. Please follow the GitHub guide to install Git on your operating system.","title":"Step 2: Installing Git"},{"location":"development/devenv/#step-3-creating-a-gpg-key","text":"Git is a distributed versioning system and you can make commits in the name of others. In order to verify committer identity (for both security and licencing purposes) we require all commits to be signed using GPG. Please follow our GPG for Git guide to enable code signing on your machine..","title":"Step 3: Creating a GPG key"},{"location":"development/devenv/#step-4-installing-golang","text":"To compile the code you will need Golang. We have a guide to install Golang on various platforms.","title":"Step 4: Installing Golang"},{"location":"development/devenv/#step-5-installing-the-qa-tools","text":"To make sure there are no latent errors are creeping in we are using some QA tools you will need .","title":"Step 5: Installing the QA tools"},{"location":"development/devenv/#step-6-installing-docker","text":"The dockerrun backend requires Docker to be installed. Please install Docker to develop against.","title":"Step 6: Installing Docker"},{"location":"development/devenv/#step-7-installing-kubernetes","text":"The kuberun backend requires Kubernetes to be installed. Please install a lightweight Kubernetes to develop against.","title":"Step 7: Installing Kubernetes"},{"location":"development/devenv/#step-8-setting-up-your-ide","text":"We have a guide to set up VSCode and Goland as your IDE.","title":"Step 8: Setting up your IDE"},{"location":"development/devenv/#step-9-website","text":"This website requires a Python to run locally . This guide explains the details of setting it up.","title":"Step 9: Website"},{"location":"development/devenv/docker/","text":"Installing Docker The dockerrun backend requires Docker to create containers. You will need this if you test against this backend. Windows / MacOS As a simple way to get Docker running we recommend installing Docker Desktop . Linux Docker provides convenience scripts to install Docker on Linux: curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh Alternatively, please follow the manual installation steps to get Docker running.","title":"Installing Docker"},{"location":"development/devenv/golang/","text":"Installing Golang While there is an official doc on installing Golang it is less than helpful for Linux users. We are attempting to collect the best practices in installing Golang for beginners here. Tip If you are using Goland as an IDE you can skip this step. Goland downloads the Go compiler for you. Linux / WSL Ubuntu 20.04 On Ubuntu 20.04 you can install Go directly from the package manager: apt update apt install golang-1.14 RHEL/CentOS yum install golang-bin Fedora dnf install golang-bin Gentoo Linux emerge --ask dev-lang/go Other / non-administrator Download the Linux .tar.gz . Extract the archive into a directory. Add the following section to your ~/.profile , ~/.zshrc , ~/.bashrc , or ~/.bash_profile , depending on your shell, then restart your terminal: export PATH = $PATH :/usr/local/bin/go We also recommend adding ~/go/bin directory to your PATH . Windows Install as administrator Golang offers an MSI-based installer for Windows that makes it easy to install Golang on your Windows machine. Follow the installation wizzard and the go command should start working in the terminal. We also recommend adding %USERPROFILE%\\go\\bin to your PATH environment variable to enable running tools from your home directory. Install as user Download the ZIP archive from the archive page Extract the ZIP file to a folder you have access to. Go to Control Panel \u2192 System and Security \u2192 System \u2192 Advanced system settings . Click on Environment variables... Change the PATH environment variable to point to the bin directory inside your Goland directory. We also recommend adding %USERPROFILE%\\go\\bin to your PATH environment variable to enable running tools from your home directory. MacOS Golang offers a PKG installer for MacOS . The go command will be located in /usr/local/go/bin . If the go command doesn't work try restarting the terminal. If it still doesn't work try running the /usr/local/go/bin/go command. If that command works edit the ~/.profile , ~/.zshrc , or ~/.bash_profile files and add the following lines then restart your terminal: export PATH = $PATH :/usr/local/bin/go We also recommend adding ~/go/bin directory to your PATH .","title":"Installing Golang"},{"location":"development/devenv/gpg/","text":"Setting up GPG for code signing ContainerSSH requires all contributors to sign their commits using GPG. GPG authenticates the committer using their GPG key. This serves two purposes: Security. In Git anyone can make commit in the name of anyone. Using GPG commits makes sure we don't accidentally merge a commit pretending to be one of the core contributors. Licensing. As you may notice, we don't have a Contributor License Agreement to make it as simple as possible for people to contribute. By signing your commits we verify that you have indeed made that commit yourself and you presumably understand that this software is open source under the MIT license. It's not 100% legally bullet proof, but it's a good tradeoff preventing contributors from having to read several pages of legalese. Setting up GPG \u00b6 Linux / WSL On Linux or Windows Subsystem for Linux GPG is already included in the package manager. You can install it using the following commands: Ubuntu sudo apt-get update sudo apt-get install gnupg2 RHEL/CentOS yum install gnupg2 Fedora dnf install gnupg2 Gentoo emerge --ask app-crypt/gnupg Tip You may want to install the Kleopatra GUI for easier access. Windows GPG4Win is a full suite for managing GPG keys on Windows. We recommend installing it with the Kleopatra GUI. MacOS Homebrew brew install gnupg2 MacPorts sudo port install gnupg2 GUI GPGTools offers a graphical version of GPG. Creating your GPG key \u00b6 CLI (GPG 2.1.17+) Run the following command: gpg --full-generate-key Select RSA and RSA as the key format. Select 4096 bits for the bit size. When prompted for your user information make sure that the e-mail address matches your GitHub e-mail and the one in your Git config , otherwise your push may be rejected. If you do not wish to publish your e-mail address GitHub gives you a privacy option . Kleopatra Select File \u2192 New Key Pair... Select \"Create a personal OpenPGP key pair\" Set your name and the same e-mail address you have on your GitHub account. If you do not wish to publish your e-mail address GitHub gives you a privacy option . Follow the wizard to create your GPG key. GPGTools (MacOS) Please follow the GPGTools guide to create your key . When prompted for your user information make sure that the e-mail address matches your GitHub e-mail and the one in your Git config , otherwise your push may be rejected. If you do not wish to publish your e-mail address GitHub gives you a privacy option . CLI (GPG 2.1.16-) Run the following command: gpg --default-new-key-algo rsa4096 --gen-key Select RSA and RSA as the key format. Select 4096 bits for the bit size. When prompted for your user information make sure that the e-mail address matches your GitHub e-mail and the one in your Git config , otherwise your push may be rejected. If you do not wish to publish your e-mail address GitHub gives you a privacy option . Adding your key to GitHub \u00b6 CLI First, list your GPG keys with the key IDs: $ gpg --list-secret-keys --key-format LONG ------------------------------------------------ sec rsa4096/YOUR-KEY-ID 2020-06-18 [SC] ... Copy the key ID as you will need it for the next steps, then export your public key: gpg --armor --export YOUR-KEY-ID Go to GitHub \u2192 Settings \u2192 SSH and GPG keys and add a GPG key. Paste the key you just copied into the interface. Kleopatra Right click the key generated in the previous step. Select \"Export...\". Save the file on your machine. Open the file in a text editor. Copy the key. Go to GitHub \u2192 Settings \u2192 SSH and GPG keys and add a GPG key. Paste the key you just copied into the interface. GPGTools (MacOS) Select the previously generated key. Click the \"Export\" icon in the toolbar. Click Save. Open the file in a text editor. Copy the key. Go to GitHub \u2192 Settings \u2192 SSH and GPG keys and add a GPG key. Paste the key you just copied into the interface. Setting up GPG signing in Git \u00b6 Global This method sets up automatic code signing for all git repositories on your computer. Run the following commands under your user account: git config --global user.name \"Your Name\" git config --global user.email \"your-gpg-email@example.com\" git config --global commit.gpgsign true git config --global tag.gpgsign true git config --global user.signingkey YOUR-KEY-ID Per repository Run the following commands in the directory where you cloned the repository: git config user.name \"Your Name\" git config user.email \"your-gpg-email@example.com\" git config commit.gpgsign true git config tag.gpgsign true git config user.signingkey YOUR-KEY-ID Warning This method sets up GPG signing in a single repository. You must configure this every time you clone a new ContainerSSH repository . That's it! You can now continue with setting up the toolchain !","title":"Installing GPG"},{"location":"development/devenv/gpg/#setting-up-gpg","text":"Linux / WSL On Linux or Windows Subsystem for Linux GPG is already included in the package manager. You can install it using the following commands: Ubuntu sudo apt-get update sudo apt-get install gnupg2 RHEL/CentOS yum install gnupg2 Fedora dnf install gnupg2 Gentoo emerge --ask app-crypt/gnupg Tip You may want to install the Kleopatra GUI for easier access. Windows GPG4Win is a full suite for managing GPG keys on Windows. We recommend installing it with the Kleopatra GUI. MacOS Homebrew brew install gnupg2 MacPorts sudo port install gnupg2 GUI GPGTools offers a graphical version of GPG.","title":"Setting up GPG"},{"location":"development/devenv/gpg/#creating-your-gpg-key","text":"CLI (GPG 2.1.17+) Run the following command: gpg --full-generate-key Select RSA and RSA as the key format. Select 4096 bits for the bit size. When prompted for your user information make sure that the e-mail address matches your GitHub e-mail and the one in your Git config , otherwise your push may be rejected. If you do not wish to publish your e-mail address GitHub gives you a privacy option . Kleopatra Select File \u2192 New Key Pair... Select \"Create a personal OpenPGP key pair\" Set your name and the same e-mail address you have on your GitHub account. If you do not wish to publish your e-mail address GitHub gives you a privacy option . Follow the wizard to create your GPG key. GPGTools (MacOS) Please follow the GPGTools guide to create your key . When prompted for your user information make sure that the e-mail address matches your GitHub e-mail and the one in your Git config , otherwise your push may be rejected. If you do not wish to publish your e-mail address GitHub gives you a privacy option . CLI (GPG 2.1.16-) Run the following command: gpg --default-new-key-algo rsa4096 --gen-key Select RSA and RSA as the key format. Select 4096 bits for the bit size. When prompted for your user information make sure that the e-mail address matches your GitHub e-mail and the one in your Git config , otherwise your push may be rejected. If you do not wish to publish your e-mail address GitHub gives you a privacy option .","title":"Creating your GPG key"},{"location":"development/devenv/gpg/#adding-your-key-to-github","text":"CLI First, list your GPG keys with the key IDs: $ gpg --list-secret-keys --key-format LONG ------------------------------------------------ sec rsa4096/YOUR-KEY-ID 2020-06-18 [SC] ... Copy the key ID as you will need it for the next steps, then export your public key: gpg --armor --export YOUR-KEY-ID Go to GitHub \u2192 Settings \u2192 SSH and GPG keys and add a GPG key. Paste the key you just copied into the interface. Kleopatra Right click the key generated in the previous step. Select \"Export...\". Save the file on your machine. Open the file in a text editor. Copy the key. Go to GitHub \u2192 Settings \u2192 SSH and GPG keys and add a GPG key. Paste the key you just copied into the interface. GPGTools (MacOS) Select the previously generated key. Click the \"Export\" icon in the toolbar. Click Save. Open the file in a text editor. Copy the key. Go to GitHub \u2192 Settings \u2192 SSH and GPG keys and add a GPG key. Paste the key you just copied into the interface.","title":"Adding your key to GitHub"},{"location":"development/devenv/gpg/#setting-up-gpg-signing-in-git","text":"Global This method sets up automatic code signing for all git repositories on your computer. Run the following commands under your user account: git config --global user.name \"Your Name\" git config --global user.email \"your-gpg-email@example.com\" git config --global commit.gpgsign true git config --global tag.gpgsign true git config --global user.signingkey YOUR-KEY-ID Per repository Run the following commands in the directory where you cloned the repository: git config user.name \"Your Name\" git config user.email \"your-gpg-email@example.com\" git config commit.gpgsign true git config tag.gpgsign true git config user.signingkey YOUR-KEY-ID Warning This method sets up GPG signing in a single repository. You must configure this every time you clone a new ContainerSSH repository . That's it! You can now continue with setting up the toolchain !","title":"Setting up GPG signing in Git"},{"location":"development/devenv/ide/","text":"Setting up an IDE We strongly recommend setting up an IDE to warn you about potential issues and make the development process easier. Visual Studio Code \u00b6 Visual Studio Code is a free IDE for various languages from Microsoft for Windows, MacOS and Linux. It can be installed without admin permissions. Once you have installed it, please click the \"Extensions\" icon on the left and install the \"Go\" extension. You can then click the \"Explorer\" icon and click the \"Clone Repository\" button to clone a ContainerSSH repository . When you clone the repository you will be asked to install other tools, such as the delve debugger . Please install them. Once the repository is set up you can go to the file you want to run (e.g. cmd/containerssh/containerssh.go ), then go to the Run \u2192 Add configuration . You can then customize the parameters of running the program (e.g. where to get the config file from). To run tests open the test file (e.g. godogs_test.go ), click on TestMain and click the little \"run test\" text that comes up. The details of running ContainerSSH are discussed in the Getting started with ContainerSSH Development guide. Goland \u00b6 Goland is a commercial IDE from Jetbrains often used for Go development. It contains a number of analysis tools and quality of life features making it a popular choice. We recommend installing Goland using the Jetbrains Toolbox which will also keep it up to date. Once you launch Goland you will have the option to directly clone a Git repository. However, we recommend first going into the settings, then to Go \u2192 GOROOT and setting up Go. Once you have cloned the repository you can navigate to the file you want to run (e.g. cmd/containerssh/containerssh.go ), then click the little \"run\" icon next to the main function and click the \"Create\" button. This will create a configuration you can edit from the \"Run\" menu. To run the tests you can open the specific test you want to run or create a go test configuration from the Run menu. The details of running ContainerSSH are discussed in the Getting started with ContainerSSH Development guide.","title":"Setting up your IDE"},{"location":"development/devenv/ide/#visual-studio-code","text":"Visual Studio Code is a free IDE for various languages from Microsoft for Windows, MacOS and Linux. It can be installed without admin permissions. Once you have installed it, please click the \"Extensions\" icon on the left and install the \"Go\" extension. You can then click the \"Explorer\" icon and click the \"Clone Repository\" button to clone a ContainerSSH repository . When you clone the repository you will be asked to install other tools, such as the delve debugger . Please install them. Once the repository is set up you can go to the file you want to run (e.g. cmd/containerssh/containerssh.go ), then go to the Run \u2192 Add configuration . You can then customize the parameters of running the program (e.g. where to get the config file from). To run tests open the test file (e.g. godogs_test.go ), click on TestMain and click the little \"run test\" text that comes up. The details of running ContainerSSH are discussed in the Getting started with ContainerSSH Development guide.","title":"Visual Studio Code"},{"location":"development/devenv/ide/#goland","text":"Goland is a commercial IDE from Jetbrains often used for Go development. It contains a number of analysis tools and quality of life features making it a popular choice. We recommend installing Goland using the Jetbrains Toolbox which will also keep it up to date. Once you launch Goland you will have the option to directly clone a Git repository. However, we recommend first going into the settings, then to Go \u2192 GOROOT and setting up Go. Once you have cloned the repository you can navigate to the file you want to run (e.g. cmd/containerssh/containerssh.go ), then click the little \"run\" icon next to the main function and click the \"Create\" button. This will create a configuration you can edit from the \"Run\" menu. To run the tests you can open the specific test you want to run or create a go test configuration from the Run menu. The details of running ContainerSSH are discussed in the Getting started with ContainerSSH Development guide.","title":"Goland"},{"location":"development/devenv/kubernetes/","text":"Installing Kubernetes If you develop against the kuberun backend you will need a working Kubernetes. Windows / MacOS Docker Desktop contains a working Kubernetes. Please enable it to have a working Kubernetes setup. You can test it by running: kubectl get nodes Windows / WSL For WSL we recommend setting up KinD (Kubernetes in Docker) . Please read the KinD guide for getting it running. Please create a cluster with the oldest officially supported Kubernetes to test against: kind create cluster --image=image-url-here You can obtain the image URL from the KinD releases section . Linux We recommend using KinD (Kubernetes in Docker) as a reliable way to get a Kubernetes cluster running. Please create a cluster with the oldest officially supported Kubernetes to test against: kind create cluster --image=image-url-here You can obtain the image URL from the KinD releases section . Tip Some Linux distributions may support tiny Kubernetes distributions like k3s or microk8s , but we have managed to get consistently good results only with KinD.","title":"Installing Kubernetes"},{"location":"development/devenv/qa/","text":"Installing the QA tools Installing golangci-lint \u00b6 We are using golangci-lint as a way to lint the code for problematic practices. We use golangci-li using the following command line: golangci-lint -E asciicheck -E bodyclose -E dupl -E errorlint -E exportloopref -E funlen Please follow the instructions below: Linux / WSL Go to the GitHub releases of golangci-lint and download the latest Linux .tar.gz . Extract the file to a directory in your path (e.g. ~/bin/go ). Add executable rights to the file (e.g. chmod +x ~/bin/go/golangci-lint ). Windows Go to the GitHub releases of golangci-lint and download the latest Windows ZIP. Extract the golangci-lint.exe to your %USERPROFILE%/go/bin directory. Brew (MacOS) brew install golangci-lint MacPorts (MacOS) sudo port install golangci-lint Manual (All platforms) Go to the GitHub releases of golangci-lint and download the latest archive for your platform. Extract the golangci-lint to the go/bin directory in your home directory.","title":"Installing the QA tools"},{"location":"development/devenv/qa/#installing-golangci-lint","text":"We are using golangci-lint as a way to lint the code for problematic practices. We use golangci-li using the following command line: golangci-lint -E asciicheck -E bodyclose -E dupl -E errorlint -E exportloopref -E funlen Please follow the instructions below: Linux / WSL Go to the GitHub releases of golangci-lint and download the latest Linux .tar.gz . Extract the file to a directory in your path (e.g. ~/bin/go ). Add executable rights to the file (e.g. chmod +x ~/bin/go/golangci-lint ). Windows Go to the GitHub releases of golangci-lint and download the latest Windows ZIP. Extract the golangci-lint.exe to your %USERPROFILE%/go/bin directory. Brew (MacOS) brew install golangci-lint MacPorts (MacOS) sudo port install golangci-lint Manual (All platforms) Go to the GitHub releases of golangci-lint and download the latest archive for your platform. Extract the golangci-lint to the go/bin directory in your home directory.","title":"Installing golangci-lint"},{"location":"development/devenv/website/","text":"Setting up the website development environment This website is developed using mkdocs using the Material theme . This guide will run you through the steps of setting it up. Installing Python \u00b6 You can download Python from the official website . You will need at least Python 3.8. Cloning the repository \u00b6 In order to develop this website you will need to clone the repository: git clone https://github.com/containerssh/containerssh.github.io Creating a venv \u00b6 Once you have all that done we recommend you create a venv to avoid polluting your computer with packages: python3 -m venv /path/to/containerssh.github.io You can then activate the venv using the following script: venv/Scripts/activate Installing the dependencies \u00b6 Now you need to install the dependencies: pip install -r requirements.txt Optional: Setting the GITHUB_TOKEN \u00b6 Some functions of the website require a working GitHub Token without any special permissions. You can create a token here . You can then set the token using the command line: Linux / MacOS export GITHUB_TOKEN=\"your-token-here\" Windows (PowerShell) $env:GITHUB_TOKEN=\"your-token-here\" Windows (Command prompt) set GITHUB_TOKEN=your-token-here Warning Setting GITHUB_TOKEN dramatically slows down the development server because the GitHub API is queried for every refresh. Only set it when you need it. Running the dev server \u00b6 Run the following command to get a dev server up and running: python -m mkdocs serve This will start the development server on localhost:8000 . Tip We recommend using the free Visual Studio Code or the PyCharm Community Edition as a development environment for the website.","title":"Setting up the website"},{"location":"development/devenv/website/#installing-python","text":"You can download Python from the official website . You will need at least Python 3.8.","title":"Installing Python"},{"location":"development/devenv/website/#cloning-the-repository","text":"In order to develop this website you will need to clone the repository: git clone https://github.com/containerssh/containerssh.github.io","title":"Cloning the repository"},{"location":"development/devenv/website/#creating-a-venv","text":"Once you have all that done we recommend you create a venv to avoid polluting your computer with packages: python3 -m venv /path/to/containerssh.github.io You can then activate the venv using the following script: venv/Scripts/activate","title":"Creating a venv"},{"location":"development/devenv/website/#installing-the-dependencies","text":"Now you need to install the dependencies: pip install -r requirements.txt","title":"Installing the dependencies"},{"location":"development/devenv/website/#optional-setting-the-github_token","text":"Some functions of the website require a working GitHub Token without any special permissions. You can create a token here . You can then set the token using the command line: Linux / MacOS export GITHUB_TOKEN=\"your-token-here\" Windows (PowerShell) $env:GITHUB_TOKEN=\"your-token-here\" Windows (Command prompt) set GITHUB_TOKEN=your-token-here Warning Setting GITHUB_TOKEN dramatically slows down the development server because the GitHub API is queried for every refresh. Only set it when you need it.","title":"Optional: Setting the GITHUB_TOKEN"},{"location":"development/devenv/website/#running-the-dev-server","text":"Run the following command to get a dev server up and running: python -m mkdocs serve This will start the development server on localhost:8000 . Tip We recommend using the free Visual Studio Code or the PyCharm Community Edition as a development environment for the website.","title":"Running the dev server"},{"location":"getting-started/","text":"Quick start This is a quick start guide to get a test server up and running in less than 5 minutes with docker-compose . Warning This setup will let any password authenticate. Only use it for testing. Step 1: Set up a Dockerized environment \u00b6 To run this quick start please make sure you have a working Docker environment and a working docker-compose . Step 2: download the sample files \u00b6 Please download the contents of the example directory from the source code repository. Step 3: Launch ContainerSSH \u00b6 In the downloaded directory run docker-compose build and then docker-compose up -d . This is you server. Step 4: Logging in \u00b6 Run ssh foo@localhost -p 2222 on the same machine via a new terminal window. This is your test client. You should be able to log in with any password. Alternatively you can also try the user busybox to land in a Busybox container. Step 5: Cleaning up \u00b6 Once you're done, you can shut down the server using the docker-compose down , then remove the images using docker-compose rm . Finally, you can also remove the guest image: docker image rm containerssh/containerssh-guest-image Step 6: Making it productive \u00b6 The authentication and configuration server included in the example is a dummy server and lets any password in. To actually use ContainerSSH, you will have to write your own authentication server and you may want to write your own configuration server too . We recommend reading the architecture overview before proceeding. Tip You can pass the CONTAINERSSH_ALLOW_ALL environment variable to the demo auth-config server to build a honeypot.","title":"Quick Start"},{"location":"getting-started/#step-1-set-up-a-dockerized-environment","text":"To run this quick start please make sure you have a working Docker environment and a working docker-compose .","title":"Step 1: Set up a Dockerized environment"},{"location":"getting-started/#step-2-download-the-sample-files","text":"Please download the contents of the example directory from the source code repository.","title":"Step 2: download the sample files"},{"location":"getting-started/#step-3-launch-containerssh","text":"In the downloaded directory run docker-compose build and then docker-compose up -d . This is you server.","title":"Step 3: Launch ContainerSSH"},{"location":"getting-started/#step-4-logging-in","text":"Run ssh foo@localhost -p 2222 on the same machine via a new terminal window. This is your test client. You should be able to log in with any password. Alternatively you can also try the user busybox to land in a Busybox container.","title":"Step 4: Logging in"},{"location":"getting-started/#step-5-cleaning-up","text":"Once you're done, you can shut down the server using the docker-compose down , then remove the images using docker-compose rm . Finally, you can also remove the guest image: docker image rm containerssh/containerssh-guest-image","title":"Step 5: Cleaning up"},{"location":"getting-started/#step-6-making-it-productive","text":"The authentication and configuration server included in the example is a dummy server and lets any password in. To actually use ContainerSSH, you will have to write your own authentication server and you may want to write your own configuration server too . We recommend reading the architecture overview before proceeding. Tip You can pass the CONTAINERSSH_ALLOW_ALL environment variable to the demo auth-config server to build a honeypot.","title":"Step 6: Making it productive"},{"location":"getting-started/architecture/","text":"Architecture ContainerSSH is a modular software that consists of the following main components: +------+ +--------------+ 2. +-------------------+ | | | | ---> | Auth Server | | | | | +-------------------+ | | | | | | 1. | | 3. +-------------------+ | User | ---> | ContainerSSH | ---> | Config Server | | | | | +-------------------+ | | | | | | | | 4. +-------------------+ | | | | ---> | Docker/Kubernetes | +------+ +--------------+ +-------------------+ The user connects ContainerSSH using an SSH client (e.g. PuTTY) ContainerSSH performs the handshake and offers the user the authentication methods supported. ContainerSSH will submit the users SSH key or password to the authentication server using HTTP (TLS encryption and authentication possible.) For more details see the page about the Auth Server . If the authentication is successful ContainerSSH will optionally contact the Config Server to fetch the container backend configuration. The config server can pass anything from container backend credentials to image configuration to ContainerSSH. For more details see the page about the Config Server . When the users SSH client requests a shell or program ContainerSSH contacts the backend configured (Docker or Kubernetes) and launches the desired Pod / Container. Currently, each new shell or program request launches a new container. For more details see the backends page . The authentication and configuration servers are not part of ContainerSSH and you will need to provide them.","title":"Architecture"},{"location":"getting-started/authserver/","text":"Implementing an authentication server ContainerSSH does not know your users and their passwords. Therefore, it calls out to a microservice that you have to provide. Your service can verify the users, passwords, and SSH keys. You will have to provide the microservice URL in the configuration. auth : url : \"http://your-server-name/\" Tip We have an OpenAPI document available for the authentication and configuration server. You can check the exact values available there, or use the OpenAPI document to generate parts of your server code. For password authentication ContainerSSH will call out to the /password path on your authentication server. The request body will be the following: { \"username\" : \"username\" , \"remoteAddress\" : \"127.0.0.1:1234\" , \"sessionId\" : \"A base64 SSH session ID\" , \"passwordBase64\" : \"Base 64 password\" } The public key auth ContainerSSH will call out to /pubkey in the following format: { \"username\" : \"username\" , \"remoteAddress\" : \"127.0.0.1:1234\" , \"sessionId\" : \"A base64 SSH session ID\" , \"publicKeyBase64\" : \"Base 64 public key in SSH wire format\" } The public key is provided in the SSH wire format in base64 encoding. Your server will need to respond with the following JSON: { \"success\" : true } Tip You can find the source code for a test authentication and configuration server written in Go in the code repository","title":"Authentication Server"},{"location":"getting-started/configserver/","text":"Writing a configuration server ContainerSSH has the ability to configure the backend and the launched container dynamically based on the username and/or IP address. To do this ContainerSSH calls out to a configuration server if configured. You have the option to dynamically change the configuration based on the username by providing a config server URL: configserver : url : http://your-config-server-url/ Once you have this configured you can launch an HTTP server that returns a configuration fragment as described below on that address. Note We have an OpenAPI document available for the authentication and configuration server. You can check the exact values available there, or use the OpenAPI document to generate parts of your server code. The config server will receive a request in following format: { \"username\" : \"ssh username\" , \"sessionId\" : \"ssh session ID\" } Your application will have to respond in the following format: { \"config\" : { // Provide a par t ial co nf igura t io n here } } You can view the full configuration structure in YAML format by running ./containerssh --dump-config . Note that your config server must respond in JSON format. Some configuration values cannot be overridden from the config server. These are the ones that get used before the connection is established, but the backends also override a few, such as attachstdio .","title":"Configuration Server"},{"location":"getting-started/configuration/","text":"Configuring ContainerSSH Before you can run ContainerSSH, you will need to create a configuration file. The minimal configuration file looks like this: ssh : hostkeys : # Generate a host key with openssl genrsa - /path/to/your/host/key auth : # See auth server below url : http://your-auth-server/ password : true # Perform password authentication pubkey : false # Perform public key authentication The config file must end in .yml , .yaml , or .json . You can dump the entire configuration file using ./containerssh --dump-config Note Parts of the configuration can be provided dynamically based on the username using a configserver . Note In order to actually use ContainerSSH you will also need to provide a backend configuration either via this file or via the configserver .","title":"Configuration"},{"location":"getting-started/faq/","text":"FAQ Is ContainerSSH secure? \u00b6 ContainerSSH depends on a number of libraries to achieve what it does. A security hole in any of the critical ones could mean a compromise of your container environment, especially if you are using the dockerrun backend. (Docker has no access control so a compromise means your whole host is compromised.) Please read the hardening guide if you intend to use ContainerSSH in production. Is ContainerSSH production-ready? \u00b6 ContainerSSH is in use by several companies in production and has caused no issues or crashes. That being said, it is very early in its development and the API and configuration file format may still change. If you intend to use ContainerSSH in production please read the hardening guide and feel free to reach out . Does ContainerSSH delete containers after it is done? \u00b6 ContainerSSH does its best to delete containers it creates. However, at this time there is no cleanup mechanism in case it crashes. Do I need to run ContainerSSH as root? \u00b6 No! In fact, you shouldn't! ContainerSSH is perfectly fine running as non-root as long as it has access to Kubernetes or Docker. (Granted, access to the Docker socket means it could easily launch a root process on the host.) Does ContainerSSH support SFTP? \u00b6 Yes, but your container image must contain an SFTP server binary and your config.yaml or config server must contain the correct path for the server. Does ContainerSSH support SCP? \u00b6 Not at this time. Does ContainerSSH support TCP port forwarding? \u00b6 Not at this time. TCP port forwarding is done outside of a channel. At this time ContainerSSH launches one container per SSH channel, so forwarding TCP ports would mean a complete overhaul of the entire architecture. In essence the architecture would be changed to launch one container per session, not per channel, and use exec to launch a shell or SFTP server for the channel. However, as you might imagine that's a bit of a larger change and will need a bit of work. Does ContainerSSH support SSH agent forwarding? \u00b6 Not at this time. SSH agent forwarding would require a separate binary agent within the container to proxy data. This is similar to how TCP port forwarding works, except that the authentication agent requests are sent on a per-channel basis. Additionally, SSH agent forwarding is not documented well, it is proprietary to OpenSSH. (The request type is auth-agent-req@openssh.com .) Does ContainerSSH support X11 forwarding? \u00b6 Not at this time. X11 is sent over separate channels and would most probably need the overhaul that TCP port forwarding requires. As X11 forwarding isn't used much anymore, it is unlikely that ContainerSSH will ever support it. Does ContainerSSH support forwarding signals? \u00b6 Partially. The dockerrun backend supports it, the kuberun backend doesn't because Kubernetes itself doesn't. Does ContainerSSH support window resizing? \u00b6 Yes. Does ContainerSSH support environment variable passing? \u00b6 Yes. Does ContainerSSH support returning the exit status? \u00b6 Partially. The dockerrun backend supports it, the kuberun backend \u201cdoes its best\u201d but has some edge cases when the connection closes before the exit status can be obtained. Can ContainerSSH run exec into existing containers? \u00b6 Not at this time. The architecture needs to solidify before such a feature is implemented. Can ContainerSSH deploy additional services, such as sidecar containers, etc? \u00b6 ContainerSSH supports the entire Kubernetes pod specification so you can launch as many containers as you want in a single pod. The Docker backend, however, does not support sidecar containers. Can I add metadata to my pods with the kuberun backend? \u00b6 Not at this time. You may want to open up a feature request and detail your use case. Why is the kuberun backend so slow? \u00b6 Kubernetes is built for scale. That means there are some tradeoffs in terms of responsiveness. This is not something ContainerSSH can do anything about, it just takes a bit to launch a pod. You may want to fine-tune your Kubernetes cluster for responsiveness. Why is there no initial prompt with the kuberun backend? \u00b6 This is a known bug . Unfortunately the kuberun backend was built by reverse engineering kubectl as there is no documentation whatsoever on how the attach functionality works on pods. If you are good with Go you might want to help out here. Can I use my normal kubeconfig files? \u00b6 Unfortunately, no. Kubeconfig files are parsed by kubectl and the code is quite elaborate. At this time, adding it to ContainerSSH is not planned. Why does the kuberun backend have so many things it doesn't support? \u00b6 The kuberun backend was written by reverse engineering kubectl . Unfortunately the Kubernetes API is documented very poorly and is quirky in some places. Kubernetes is a very complex and fast moving beast so things like API documentation, a proper SDK and other niceties that make a developer's life easy are not something that's currently available.","title":"FAQ"},{"location":"getting-started/faq/#is-containerssh-secure","text":"ContainerSSH depends on a number of libraries to achieve what it does. A security hole in any of the critical ones could mean a compromise of your container environment, especially if you are using the dockerrun backend. (Docker has no access control so a compromise means your whole host is compromised.) Please read the hardening guide if you intend to use ContainerSSH in production.","title":"Is ContainerSSH secure?"},{"location":"getting-started/faq/#is-containerssh-production-ready","text":"ContainerSSH is in use by several companies in production and has caused no issues or crashes. That being said, it is very early in its development and the API and configuration file format may still change. If you intend to use ContainerSSH in production please read the hardening guide and feel free to reach out .","title":"Is ContainerSSH production-ready?"},{"location":"getting-started/faq/#does-containerssh-delete-containers-after-it-is-done","text":"ContainerSSH does its best to delete containers it creates. However, at this time there is no cleanup mechanism in case it crashes.","title":"Does ContainerSSH delete containers after it is done?"},{"location":"getting-started/faq/#do-i-need-to-run-containerssh-as-root","text":"No! In fact, you shouldn't! ContainerSSH is perfectly fine running as non-root as long as it has access to Kubernetes or Docker. (Granted, access to the Docker socket means it could easily launch a root process on the host.)","title":"Do I need to run ContainerSSH as root?"},{"location":"getting-started/faq/#does-containerssh-support-sftp","text":"Yes, but your container image must contain an SFTP server binary and your config.yaml or config server must contain the correct path for the server.","title":"Does ContainerSSH support SFTP?"},{"location":"getting-started/faq/#does-containerssh-support-scp","text":"Not at this time.","title":"Does ContainerSSH support SCP?"},{"location":"getting-started/faq/#does-containerssh-support-tcp-port-forwarding","text":"Not at this time. TCP port forwarding is done outside of a channel. At this time ContainerSSH launches one container per SSH channel, so forwarding TCP ports would mean a complete overhaul of the entire architecture. In essence the architecture would be changed to launch one container per session, not per channel, and use exec to launch a shell or SFTP server for the channel. However, as you might imagine that's a bit of a larger change and will need a bit of work.","title":"Does ContainerSSH support TCP port forwarding?"},{"location":"getting-started/faq/#does-containerssh-support-ssh-agent-forwarding","text":"Not at this time. SSH agent forwarding would require a separate binary agent within the container to proxy data. This is similar to how TCP port forwarding works, except that the authentication agent requests are sent on a per-channel basis. Additionally, SSH agent forwarding is not documented well, it is proprietary to OpenSSH. (The request type is auth-agent-req@openssh.com .)","title":"Does ContainerSSH support SSH agent forwarding?"},{"location":"getting-started/faq/#does-containerssh-support-x11-forwarding","text":"Not at this time. X11 is sent over separate channels and would most probably need the overhaul that TCP port forwarding requires. As X11 forwarding isn't used much anymore, it is unlikely that ContainerSSH will ever support it.","title":"Does ContainerSSH support X11 forwarding?"},{"location":"getting-started/faq/#does-containerssh-support-forwarding-signals","text":"Partially. The dockerrun backend supports it, the kuberun backend doesn't because Kubernetes itself doesn't.","title":"Does ContainerSSH support forwarding signals?"},{"location":"getting-started/faq/#does-containerssh-support-window-resizing","text":"Yes.","title":"Does ContainerSSH support window resizing?"},{"location":"getting-started/faq/#does-containerssh-support-environment-variable-passing","text":"Yes.","title":"Does ContainerSSH support environment variable passing?"},{"location":"getting-started/faq/#does-containerssh-support-returning-the-exit-status","text":"Partially. The dockerrun backend supports it, the kuberun backend \u201cdoes its best\u201d but has some edge cases when the connection closes before the exit status can be obtained.","title":"Does ContainerSSH support returning the exit status?"},{"location":"getting-started/faq/#can-containerssh-run-exec-into-existing-containers","text":"Not at this time. The architecture needs to solidify before such a feature is implemented.","title":"Can ContainerSSH run exec into existing containers?"},{"location":"getting-started/faq/#can-containerssh-deploy-additional-services-such-as-sidecar-containers-etc","text":"ContainerSSH supports the entire Kubernetes pod specification so you can launch as many containers as you want in a single pod. The Docker backend, however, does not support sidecar containers.","title":"Can ContainerSSH deploy additional services, such as sidecar containers, etc?"},{"location":"getting-started/faq/#can-i-add-metadata-to-my-pods-with-the-kuberun-backend","text":"Not at this time. You may want to open up a feature request and detail your use case.","title":"Can I add metadata to my pods with the kuberun backend?"},{"location":"getting-started/faq/#why-is-the-kuberun-backend-so-slow","text":"Kubernetes is built for scale. That means there are some tradeoffs in terms of responsiveness. This is not something ContainerSSH can do anything about, it just takes a bit to launch a pod. You may want to fine-tune your Kubernetes cluster for responsiveness.","title":"Why is the kuberun backend so slow?"},{"location":"getting-started/faq/#why-is-there-no-initial-prompt-with-the-kuberun-backend","text":"This is a known bug . Unfortunately the kuberun backend was built by reverse engineering kubectl as there is no documentation whatsoever on how the attach functionality works on pods. If you are good with Go you might want to help out here.","title":"Why is there no initial prompt with the kuberun backend?"},{"location":"getting-started/faq/#can-i-use-my-normal-kubeconfig-files","text":"Unfortunately, no. Kubeconfig files are parsed by kubectl and the code is quite elaborate. At this time, adding it to ContainerSSH is not planned.","title":"Can I use my normal kubeconfig files?"},{"location":"getting-started/faq/#why-does-the-kuberun-backend-have-so-many-things-it-doesnt-support","text":"The kuberun backend was written by reverse engineering kubectl . Unfortunately the Kubernetes API is documented very poorly and is quirky in some places. Kubernetes is a very complex and fast moving beast so things like API documentation, a proper SDK and other niceties that make a developer's life easy are not something that's currently available.","title":"Why does the kuberun backend have so many things it doesn't support?"},{"location":"getting-started/getting-help/","text":"Getting help Sometimes the best documentation can leave you stuck with an issue. If you need help, want to discuss a topic around ContainerSSH, or have feedback you can use our GitHub Discussions Board to post a question.","title":"Getting Help"},{"location":"getting-started/installation/","text":"Installing ContainerSSH ContainerSSH is provided on the GitHub releases page . You can install it in a containerized environment or as a standalone software on Windows, Linux, and MacOS. Running in a containerized environment \u00b6 When running ContainerSSH in a containerized environment we recommend using the image containerssh/containerssh . You will also need to mount or provide the following files: /etc/containerssh/config.yaml This is the base configuration file . Parts of it can be modified by the configuration server call. /var/secrets/ssh_host_rsa_key : This is the default path for the host key. You can generate this host key using the OpenSSL tool: openssl genrsa > /var/secrets/ssh_host_rsa_key When using the dockerrun backend, you can also mount /var/run/docker.sock into the container. Please note, in this case the Docker socket must be accessible by the user with the uid 1022. Alternatively, you can set up the Docker socket via TCP . When using the kuberun backend you must provide credentials via the configuration file or the configserver Running as a standalone application \u00b6 ContainerSSH is supplied as a single binary that runs on all major platforms. After downloading the binary and creating the configuration file you can run ContainerSSH with the following command: containerssh --config /path/to/your/configuration/file","title":"Installation"},{"location":"getting-started/installation/#running-in-a-containerized-environment","text":"When running ContainerSSH in a containerized environment we recommend using the image containerssh/containerssh . You will also need to mount or provide the following files: /etc/containerssh/config.yaml This is the base configuration file . Parts of it can be modified by the configuration server call. /var/secrets/ssh_host_rsa_key : This is the default path for the host key. You can generate this host key using the OpenSSL tool: openssl genrsa > /var/secrets/ssh_host_rsa_key When using the dockerrun backend, you can also mount /var/run/docker.sock into the container. Please note, in this case the Docker socket must be accessible by the user with the uid 1022. Alternatively, you can set up the Docker socket via TCP . When using the kuberun backend you must provide credentials via the configuration file or the configserver","title":"Running in a containerized environment"},{"location":"getting-started/installation/#running-as-a-standalone-application","text":"ContainerSSH is supplied as a single binary that runs on all major platforms. After downloading the binary and creating the configuration file you can run ContainerSSH with the following command: containerssh --config /path/to/your/configuration/file","title":"Running as a standalone application"},{"location":"getting-started/backends/","text":"Backend selection ContainerSSH is built to support multiple backends. The backend can be changed in the configuration file: # change to `kuberun` to talk to Kubernetes backend : dockerrun","title":"Selecting a Backend"},{"location":"getting-started/backends/dockerrun/","text":"The dockerrun backend The dockerrun backend launches a container using the Docker API Providing certificates \u00b6 Docker sockets allow connections over TCP with TLS encryption. You can provide these TLS certificates embedded in the YAML file in PEM format: dockerrun : host : tcp://127.0.0.1:2376 cacert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- cert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- key : | -----BEGIN RSA PRIVATE KEY----- ... -----END RSA PRIVATE KEY----- Changing the container image \u00b6 The container image depends on the backend you are using. For dockerrun you can change the image in the config file: dockerrun : config : container : image : your/image Detailed configuration \u00b6 The full configuration at the time of writing are as described below. Keep in mind that the configuration structure may change over time as they follow the Docker API . dockerrun : host : tcp://127.0.0.1:2375 cacert : \"\" cert : \"\" key : \"\" config : container : hostname : \"\" domainname : \"\" user : \"\" # The \"attach\" options are overridden and cannot be configured #attachstdin: false #attachstdout: false #attachstderr: false exposedports : {} # The \"tty\" option depends on the requested SSH mode and cannot be configured #tty: false # The \"stdin\" options are also configured by the backend #openstdin: false #stdinonce: false # Env can be configured but will be overridden by the values provided via SSH env : [] # CMD can be provided but will be overridden by the command sent via SSH cmd : [] healthcheck : null argsescaped : false image : containerssh/containerssh-guest-image volumes : {} workingdir : \"\" entrypoint : [] networkdisabled : false macaddress : \"\" onbuild : [] labels : {} stopsignal : \"\" stoptimeout : null shell : [] host : binds : [] containeridfile : \"\" logconfig : type : \"\" config : {} networkmode : \"\" portbindings : {} restartpolicy : name : \"\" maximumretrycount : 0 autoremove : false volumedriver : \"\" volumesfrom : [] capadd : [] capdrop : [] dns : [] dnsoptions : [] dnssearch : [] extrahosts : [] groupadd : [] ipcmode : \"\" cgroup : \"\" links : [] oomscoreadj : 0 pidmode : \"\" privileged : false publishallports : false readonlyrootfs : false securityopt : [] storageopt : {} tmpfs : {} utsmode : \"\" usernsmode : \"\" shmsize : 0 sysctls : {} runtime : \"\" consolesize : - 0 - 0 isolation : \"\" resources : cpushares : 0 memory : 0 nanocpus : 0 cgroupparent : \"\" blkioweight : 0 blkioweightdevice : [] blkiodevicereadbps : [] blkiodevicewritebps : [] blkiodevicereadiops : [] blkiodevicewriteiops : [] cpuperiod : 0 cpuquota : 0 cpurealtimeperiod : 0 cpurealtimeruntime : 0 cpusetcpus : \"\" cpusetmems : \"\" devices : [] diskquota : 0 kernelmemory : 0 memoryreservation : 0 memoryswap : 0 memoryswappiness : null oomkilldisable : null pidslimit : 0 ulimits : [] cpucount : 0 cpupercent : 0 iomaximumiops : 0 iomaximumbandwidth : 0 mounts : [] init : null initpath : \"\" network : endpointsconfig : {} containername : \"\" subsystems : # This will be used as `command` when the client asks for the SFTP subsystem. sftp : /usr/lib/openssh/sftp-server # Disable command execution via SSH. Also disables subsystem requests. disableCommand : false","title":"The dockerrun Backend"},{"location":"getting-started/backends/dockerrun/#providing-certificates","text":"Docker sockets allow connections over TCP with TLS encryption. You can provide these TLS certificates embedded in the YAML file in PEM format: dockerrun : host : tcp://127.0.0.1:2376 cacert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- cert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- key : | -----BEGIN RSA PRIVATE KEY----- ... -----END RSA PRIVATE KEY-----","title":"Providing certificates"},{"location":"getting-started/backends/dockerrun/#changing-the-container-image","text":"The container image depends on the backend you are using. For dockerrun you can change the image in the config file: dockerrun : config : container : image : your/image","title":"Changing the container image"},{"location":"getting-started/backends/dockerrun/#detailed-configuration","text":"The full configuration at the time of writing are as described below. Keep in mind that the configuration structure may change over time as they follow the Docker API . dockerrun : host : tcp://127.0.0.1:2375 cacert : \"\" cert : \"\" key : \"\" config : container : hostname : \"\" domainname : \"\" user : \"\" # The \"attach\" options are overridden and cannot be configured #attachstdin: false #attachstdout: false #attachstderr: false exposedports : {} # The \"tty\" option depends on the requested SSH mode and cannot be configured #tty: false # The \"stdin\" options are also configured by the backend #openstdin: false #stdinonce: false # Env can be configured but will be overridden by the values provided via SSH env : [] # CMD can be provided but will be overridden by the command sent via SSH cmd : [] healthcheck : null argsescaped : false image : containerssh/containerssh-guest-image volumes : {} workingdir : \"\" entrypoint : [] networkdisabled : false macaddress : \"\" onbuild : [] labels : {} stopsignal : \"\" stoptimeout : null shell : [] host : binds : [] containeridfile : \"\" logconfig : type : \"\" config : {} networkmode : \"\" portbindings : {} restartpolicy : name : \"\" maximumretrycount : 0 autoremove : false volumedriver : \"\" volumesfrom : [] capadd : [] capdrop : [] dns : [] dnsoptions : [] dnssearch : [] extrahosts : [] groupadd : [] ipcmode : \"\" cgroup : \"\" links : [] oomscoreadj : 0 pidmode : \"\" privileged : false publishallports : false readonlyrootfs : false securityopt : [] storageopt : {} tmpfs : {} utsmode : \"\" usernsmode : \"\" shmsize : 0 sysctls : {} runtime : \"\" consolesize : - 0 - 0 isolation : \"\" resources : cpushares : 0 memory : 0 nanocpus : 0 cgroupparent : \"\" blkioweight : 0 blkioweightdevice : [] blkiodevicereadbps : [] blkiodevicewritebps : [] blkiodevicereadiops : [] blkiodevicewriteiops : [] cpuperiod : 0 cpuquota : 0 cpurealtimeperiod : 0 cpurealtimeruntime : 0 cpusetcpus : \"\" cpusetmems : \"\" devices : [] diskquota : 0 kernelmemory : 0 memoryreservation : 0 memoryswap : 0 memoryswappiness : null oomkilldisable : null pidslimit : 0 ulimits : [] cpucount : 0 cpupercent : 0 iomaximumiops : 0 iomaximumbandwidth : 0 mounts : [] init : null initpath : \"\" network : endpointsconfig : {} containername : \"\" subsystems : # This will be used as `command` when the client asks for the SFTP subsystem. sftp : /usr/lib/openssh/sftp-server # Disable command execution via SSH. Also disables subsystem requests. disableCommand : false","title":"Detailed configuration"},{"location":"getting-started/backends/kuberun/","text":"The kuberun backend runs a pod in a Kubernetes cluster and attaches to a container there. Running outside of Kubernetes \u00b6 If you are running ContainerSSH outside of Kubernetes you will need the following configuration: kuberun : connection : host : your-kubernetes-api-server:6443 cert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- key : | -----BEGIN RSA PRIVATE KEY----- ... -----END RSA PRIVATE KEY----- cacert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- Alternatively you can use cacertFile , keyFile and certFile to point to files on the filesystem. Running inside a Kubernetes cluster \u00b6 When you run inside of a Kubernetes cluster you can use the service account token: kuberun : connection : certFile : /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearerTokenFile : /var/run/secrets/kubernetes.io/serviceaccount/token Changing the container image \u00b6 For the kuberun backend the container image can be changed by modifying the pod spec: kuberun : pod : namespace : default consoleContainerNumber : 0 podSpec : volumes : [] initcontainers : [] containers : - name : shell image : containerssh/containerssh-guest-image Note: if you are running multiple containers you should specify the consoleContainerNumber parameter to indicate which container you wish to attach to when an SSH session is opened. Detailed configuration \u00b6 The full configuration looks as follows: kuberun : connection : host : kubernetes.docker.internal:6443 path : /api username : docker-desktop password : \"\" insecure : false serverName : \"\" certFile : /var/run/secrets/kubernetes.io/serviceaccount/ca.crt keyFile : \"\" cacertFile : \"\" cert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- key : | -----BEGIN RSA PRIVATE KEY----- ... -----END RSA PRIVATE KEY----- cacert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- bearerToken : \"\" bearerTokenFile : \"\" qps : 5 burst : 10 timeout : 0s pod : namespace : default # If you have multiple containers which container should the SSH session attach to? consoleContainerNumber : 0 podSpec : volumes : [] initcontainers : [] containers : # The name doesn't matter - name : shell image : containerssh/containerssh-guest-image # This may be overridden by the SSH client command : [] args : [] workingdir : \"\" ports : [] envfrom : [] # These will be populated from the SSH session but you can provide additional ones. env : [] resources : limits : {} requests : {} volumemounts : [] volumedevices : [] livenessprobe : null readinessprobe : null startupprobe : null lifecycle : null terminationmessagepath : \"\" terminationmessagepolicy : \"\" imagepullpolicy : \"\" securitycontext : null # These 3 will be overridden based on the SSH session #stdin: false #stdinonce: false #tty: false ephemeralcontainers : [] restartpolicy : \"\" terminationgraceperiodseconds : null activedeadlineseconds : null dnspolicy : \"\" nodeselector : {} serviceaccountname : \"\" deprecatedserviceaccount : \"\" automountserviceaccounttoken : null nodename : \"\" hostnetwork : false hostpid : false hostipc : false shareprocessnamespace : null securitycontext : null imagepullsecrets : [] hostname : \"\" subdomain : \"\" affinity : null schedulername : \"\" tolerations : [] hostaliases : [] priorityclassname : \"\" priority : null dnsconfig : null readinessgates : [] runtimeclassname : null enableservicelinks : null preemptionpolicy : null overhead : {} topologyspreadconstraints : [] subsystems : # This will be used as `command` when the client asks for the SFTP subsystem. sftp : /usr/lib/openssh/sftp-server # Disable command execution via SSH. Also disables subsystem requests. disableCommand : false timeout : 1m0s","title":"The kuberun Backend"},{"location":"getting-started/backends/kuberun/#running-outside-of-kubernetes","text":"If you are running ContainerSSH outside of Kubernetes you will need the following configuration: kuberun : connection : host : your-kubernetes-api-server:6443 cert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- key : | -----BEGIN RSA PRIVATE KEY----- ... -----END RSA PRIVATE KEY----- cacert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- Alternatively you can use cacertFile , keyFile and certFile to point to files on the filesystem.","title":"Running outside of Kubernetes"},{"location":"getting-started/backends/kuberun/#running-inside-a-kubernetes-cluster","text":"When you run inside of a Kubernetes cluster you can use the service account token: kuberun : connection : certFile : /var/run/secrets/kubernetes.io/serviceaccount/ca.crt bearerTokenFile : /var/run/secrets/kubernetes.io/serviceaccount/token","title":"Running inside a Kubernetes cluster"},{"location":"getting-started/backends/kuberun/#changing-the-container-image","text":"For the kuberun backend the container image can be changed by modifying the pod spec: kuberun : pod : namespace : default consoleContainerNumber : 0 podSpec : volumes : [] initcontainers : [] containers : - name : shell image : containerssh/containerssh-guest-image Note: if you are running multiple containers you should specify the consoleContainerNumber parameter to indicate which container you wish to attach to when an SSH session is opened.","title":"Changing the container image"},{"location":"getting-started/backends/kuberun/#detailed-configuration","text":"The full configuration looks as follows: kuberun : connection : host : kubernetes.docker.internal:6443 path : /api username : docker-desktop password : \"\" insecure : false serverName : \"\" certFile : /var/run/secrets/kubernetes.io/serviceaccount/ca.crt keyFile : \"\" cacertFile : \"\" cert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- key : | -----BEGIN RSA PRIVATE KEY----- ... -----END RSA PRIVATE KEY----- cacert : | -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- bearerToken : \"\" bearerTokenFile : \"\" qps : 5 burst : 10 timeout : 0s pod : namespace : default # If you have multiple containers which container should the SSH session attach to? consoleContainerNumber : 0 podSpec : volumes : [] initcontainers : [] containers : # The name doesn't matter - name : shell image : containerssh/containerssh-guest-image # This may be overridden by the SSH client command : [] args : [] workingdir : \"\" ports : [] envfrom : [] # These will be populated from the SSH session but you can provide additional ones. env : [] resources : limits : {} requests : {} volumemounts : [] volumedevices : [] livenessprobe : null readinessprobe : null startupprobe : null lifecycle : null terminationmessagepath : \"\" terminationmessagepolicy : \"\" imagepullpolicy : \"\" securitycontext : null # These 3 will be overridden based on the SSH session #stdin: false #stdinonce: false #tty: false ephemeralcontainers : [] restartpolicy : \"\" terminationgraceperiodseconds : null activedeadlineseconds : null dnspolicy : \"\" nodeselector : {} serviceaccountname : \"\" deprecatedserviceaccount : \"\" automountserviceaccounttoken : null nodename : \"\" hostnetwork : false hostpid : false hostipc : false shareprocessnamespace : null securitycontext : null imagepullsecrets : [] hostname : \"\" subdomain : \"\" affinity : null schedulername : \"\" tolerations : [] hostaliases : [] priorityclassname : \"\" priority : null dnsconfig : null readinessgates : [] runtimeclassname : null enableservicelinks : null preemptionpolicy : null overhead : {} topologyspreadconstraints : [] subsystems : # This will be used as `command` when the client asks for the SFTP subsystem. sftp : /usr/lib/openssh/sftp-server # Disable command execution via SSH. Also disables subsystem requests. disableCommand : false timeout : 1m0s","title":"Detailed configuration"},{"location":"usecases/honeypots/","text":"When left undefended, SSH can be a large attack surface towards the internet. If you leave an SSH server open to the Internet, bots will try to brute force their way in within minutes. Why not build a honeypot? Honeypots can provide valuable early warning: log the IP addresses of connection attempts and dynamically firewall them. Collect credentials attackers are trying to use and match them against your user database to root out weak passwords. Collect logs of what attackers are doing in a containerized environment. Version 0.4.0 will offer comprehensive audit logging. ContainerSSH can do all that. When a user connects, ContainerSSH reaches out to your authentication server where you can log IP addresses and credentials. If you allow attackers to connect, ContainerSSH fetches a dynamic container configuration from your configuration server . You can specify what environment and on which Docker or Kubernetes setup to run your honeypot. Restrict attackers to a set amount of resources or a networkless environment. Get started \u00bb","title":"Honeypots"},{"location":"usecases/learning/","text":"Providing console access to your students can be a hurdle. No matter if you want to provide access to a Linux environment, databases, or something else, you will have to create users, make sure they have everything they need, and clean up when they are done. Containers can provide an easier solution: launch a specific environment for a student and simply remove the container when they are done. However, manually provisioning containers can still be tedious and continuously running a large number of containers can be resource-intensive. ContainerSSH provides a vital role here: it can dynamically launch containers as needed. When users connect via SSH, ContainerSSH reaches out to your authentication server to verify user credentials and then contacts your configuration server to fetch the customized container configuration for your user. When your user disconnects, ContainerSSH removes their container and leaves no trace behind. Get started \u00bb","title":"Learning environments"},{"location":"usecases/security/","text":"Do you need to provide secure access to a console environment and highly sensitive credentials to users? Key management systems like HashiCorp Vault can change credentials frequently to counteract credential leakage or theft by users. However, educating your users to use the key management system can be time-consuming. ContainerSSH provides a user-friendly solution. When your users connect to the SSH server it reaches out to an authentication server provided by you. This lets you authenticate them against your own user database using passwords or SSH keys. When authenticated successfully, ContainerSSH contacts your configuration server to get the configuration for your user. The configuration server can expose short lived credentials from the key management system in the container environment. Even if your users steal or leak the credentials, they are only valid for a short time. Additionally, the logging facilities of your container environment can track what your users are doing and version 0.4.0 will offer comprehensive audit logging. Get started \u00bb","title":"Security"},{"location":"usecases/webhosting/","text":"Providing SSH access in a web hosting environment is tricky. Users may run unexpected scripts that consume lots of resources. They may have permission issues if they are not able to SSH with the same user as the webserver, which in turn presents security issues. Containers present a good solution for this problem: you can run a container as the same user as the web server, but keep them in isolation from the actual production environment. You can use NFS mounts to isolate them from the production servers. You can even mount folders based on an advanced permission matrix. However, running an SSH server per user is very cost-intensive in an industry where individual customers don't pay much. That's where ContainerSSH fills an important role: when users connect via SSH, ContainerSSH reaches out to your authentication server to verify user credentials and then contacts your configuration server to fetch the customized container configuration for your user. When your user disconnects, ContainerSSH removes their container and leaves no trace behind. ContainerSSH also supports SFTP, which provides secure file transfers. It can replace the old and arguably broken FTP, so you no longer have to worry about that either. If you are running multiple servers, you can even provide dynamic Docker connect strings and credentials to connect the server where the user is located. Get started \u00bb","title":"Web hosting"}]}